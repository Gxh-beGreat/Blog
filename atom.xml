<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amu&#39;s blog</title>
  
  <subtitle>码匠 电子控 胶达控 深度吸犬患者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://amu.fun/"/>
  <updated>2019-02-25T08:21:42.308Z</updated>
  <id>http://amu.fun/</id>
  
  <author>
    <name>Amu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DevTools 小技巧 day 5 —— 诡异的 console.log</title>
    <link href="http://amu.fun/2018/12/10/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%205%20%E2%80%94%E2%80%94%20%E8%AF%A1%E5%BC%82%E7%9A%84%20console.log/"/>
    <id>http://amu.fun/2018/12/10/apps/DevTools小技巧/day 5 —— 诡异的 console.log/</id>
    <published>2018-12-10T02:13:20.000Z</published>
    <updated>2019-02-25T08:21:42.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h2><blockquote><p><a href="https://medium.com/@tomsu/devtools-tips-day-5-the-curious-case-of-console-log-36bc7e27a97f" target="_blank" rel="noopener">DevTools tips — day 5: the curious case of console.log</a></p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。</p><h2 id="16-记录的对象并非预期值"><a href="#16-记录的对象并非预期值" class="headerlink" title="16. 记录的对象并非预期值"></a>16. 记录的对象并非预期值</h2><p><code>console.log</code> 对于 <code>对象</code> 的输出方式，多少都让我们在调试的时候困惑过或是踩到坑：</p><blockquote><p>通过控制台输出的对象值，将通过引用的方式进行存储的，开发者展开查看到的都将会是对象的最新属性值</p></blockquote><p>这意味着如果你是记录一个对象，修改其属性值并再次 log，查看控制台，你将看到第一个日志（修改之前）…与第二个日志具有相同的值！</p><p>下面的动图会展示这种情况：<br><img src="/images/DevTools小技巧/5-1.gif" alt></p><p>现在想象一下，当你试图对比一个对象属性修改前后的值是否符合要求的时候，这个问题就很伤脑筋了~ 🤯</p><p>那么这种情况要怎么处理呢？好吧，你可能需要记录一个对象的副本（一个新的引用）或……在 <code>serious debugging</code>（译者理解为 Sources 面板中的断点代码调试） 中使用 断点 和 Sources 面板代替！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4-4&quot;&gt;&lt;a href=&quot;#4-4&quot; class=&quot;headerlink&quot; title=&quot;4-4&quot;&gt;&lt;/a&gt;4-4&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tomsu/devtools-tips-day-
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="DevTools" scheme="http://amu.fun/tags/DevTools/"/>
    
      <category term="文章翻译" scheme="http://amu.fun/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>DevTools 小技巧 day 4 —— Elements 面板</title>
    <link href="http://amu.fun/2018/12/10/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%204%20%E2%80%94%E2%80%94%20Elements%20%E9%9D%A2%E6%9D%BF/"/>
    <id>http://amu.fun/2018/12/10/apps/DevTools小技巧/day 4 —— Elements 面板/</id>
    <published>2018-12-10T02:13:20.000Z</published>
    <updated>2019-02-25T08:21:42.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h2><blockquote><p><a href="https://medium.com/@tomsu/devtools-tips-day-4-console-methods-47c854782cef" target="_blank" rel="noopener">DevTools tips — day 4: the Elements panel</a></p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。今天我们将讲一些关于 Elements 面板的使用小技巧</p><h2 id="12-使用-”h“-隐藏元素"><a href="#12-使用-”h“-隐藏元素" class="headerlink" title="12. 使用 ”h“ 隐藏元素"></a>12. 使用 ”h“ 隐藏元素</h2><p>只需按 <code>h</code> 即可隐藏在 Elements 面板中选中的元素。再次按 <code>h</code> 使其重新出现。<br>这对于网页截图，且需要隐藏部分敏感性数据时很有效</p><p><img src="/images/DevTools小技巧/4-1.gif" alt></p><h2 id="13-拖放元素"><a href="#13-拖放元素" class="headerlink" title="13. 拖放元素"></a>13. 拖放元素</h2><p>如果想要检查 html 的节点在 DOM 树的其他位置会是怎样的情况，只需使用鼠标将其拖放到对应位置，就像你在电脑上拖放文件一样:-)</p><p><img src="/images/DevTools小技巧/4-2.gif" alt></p><h2 id="14-…或使用键盘控制！"><a href="#14-…或使用键盘控制！" class="headerlink" title="14. …或使用键盘控制！"></a>14. …或使用键盘控制！</h2><p>如果你想在 DOM 结构上向下或向下移动当前选中的元素，而不是拖放，你也可以使用 <code>[ctrl] + [⬆]</code>/ <code>[ctrl] + [⬇]</code>（Mac 下使用<code>[⌘] + [⬆]</code> / <code>[⌘] + [⬇]</code>）。</p><p><img src="/images/DevTools小技巧/4-3.gif" alt></p><h2 id="15-它等同于一个编辑器"><a href="#15-它等同于一个编辑器" class="headerlink" title="15. 它等同于一个编辑器"></a>15. 它等同于一个编辑器</h2><p>我们可以在 Elements 面板里进行拖放，编辑，复制（是的，也可以使用 <code>[ctrl] + [v]</code> 进行粘贴），一旦我们弄乱了 html 结构，不需要担心，在任何文本/图形编辑器中的标准是什么：</p><ul><li>使用 <code>[ctrl] + [z]</code>（Mac 上的 <code>[⌘] + [z]</code>）撤消上一步操作</li><li>使用 <code>[ctrl] + [shift] + [z]</code> 重做撤销的操作</li></ul><p><img src="/images/DevTools小技巧/4-4.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4-4&quot;&gt;&lt;a href=&quot;#4-4&quot; class=&quot;headerlink&quot; title=&quot;4-4&quot;&gt;&lt;/a&gt;4-4&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tomsu/devtools-tips-day-
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="DevTools" scheme="http://amu.fun/tags/DevTools/"/>
    
      <category term="文章翻译" scheme="http://amu.fun/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>DevTools 小技巧 day 3 —— console 方法</title>
    <link href="http://amu.fun/2018/12/09/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%203%20%E2%80%94%E2%80%94%20console%20%E6%96%B9%E6%B3%95/"/>
    <id>http://amu.fun/2018/12/09/apps/DevTools小技巧/day 3 —— console 方法/</id>
    <published>2018-12-09T03:43:27.000Z</published>
    <updated>2019-02-25T08:21:42.308Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://medium.com/@tomsu/devtools-tips-day-3-console-methods-783791e91990" target="_blank" rel="noopener">DevTools tips — day 3: console methods</a></p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。我们在<a href="2018/12/08/apps/DevTools小技巧/day%202%20——%20复制&amp;保存/">上一篇</a>中已经介绍到了第 8 种技巧，那么今天我们将从第 9 开始。</p><h2 id="9-console-assert"><a href="#9-console-assert" class="headerlink" title="9. console.assert"></a>9. console.assert</h2><p><img src="/images/DevTools小技巧/3-1.png" alt="出自: https://developer.mozilla.org/en-US/docs/Web/API/console/assert"></p><p><code>console.assert</code> 方法第一个参数（断言）为 <code>false</code> 时，则将一个错误消息写入控制台，如果断言是 true，没有任何反应。<br>这个方法对于在特定条件下记录消息时很有用，你可以在不书写 <code>if</code> 语句的情况下执行此操作，而且你还能从这里得到对应的堆栈跟踪 😁</p><p><img src="/images/DevTools小技巧/3-2.gif" alt></p><h2 id="10-console-table"><a href="#10-console-table" class="headerlink" title="10.console.table"></a>10.console.table</h2><p>这是一个鲜为人知的方法。<br>如果你有一个数组（或类似数组的对象，或者只是一个对象），你可以使用 <code>console.table</code> 方法在控制台中以一个漂亮的表的形式打印它。<br>它不仅会基于数据所包含的属性来计算表列名称，而且列也可以调整大小甚至可排序！😳<br>如果列太多，你还可以使用第二个参数，传入需要显示的列名数组。</p><p><img src="/images/DevTools小技巧/3-3.gif" alt></p><blockquote><p>哦！如果你还同时涉猎 nodejs 后端，那么恭喜你！10.0 版本之后，你也可以使用 <code>console.table</code> 啦!</p></blockquote><h2 id="11-console-dir"><a href="#11-console-dir" class="headerlink" title="11. console.dir"></a>11. console.dir</h2><p>最常使用的 <code>console.log</code> 方法，在大多数情况下，都以最合适的格式化数据输出给开发人员，但有时它可能不是你想要看到的 —— 典型的例子是打印出一个 DOM 节点。<br><code>console.log</code> 将呈现此交互式元素，它看起来就像刚从 <code>Elements</code> 面板中剪切出来一样。<br>如果要检查它引用的实际 JavaScript 对象，该怎么办，查看它的属性等呢？<br>在这种情况下，如果您需要更多信息描述数据，请改用 <code>console.dir</code>。</p><p><img src="/images/DevTools小技巧/3-4.gif" alt></p><p>这就是今天所有的内容啦！😉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tomsu/devtools-tips-day-3-console-methods-783791e91990&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dev
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="DevTools" scheme="http://amu.fun/tags/DevTools/"/>
    
      <category term="文章翻译" scheme="http://amu.fun/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>DevTools 小技巧 day 2 —— 复制 &amp; 保存</title>
    <link href="http://amu.fun/2018/12/08/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%202%20%E2%80%94%E2%80%94%20%E5%A4%8D%E5%88%B6&amp;%E4%BF%9D%E5%AD%98/"/>
    <id>http://amu.fun/2018/12/08/apps/DevTools小技巧/day 2 —— 复制&amp;保存/</id>
    <published>2018-12-08T02:53:27.000Z</published>
    <updated>2019-02-25T08:21:42.308Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://medium.com/@tomsu/devtools-tips-day-2-copying-saving-6aa9bbdadbe21" target="_blank" rel="noopener">DevTools tips — day 2: copying &amp; saving</a></p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。我们在<a href="2018/12/06/apps/DevTools小技巧/day%201%20——%20控制台%20$/">上一篇</a>中介绍了 4 种技巧，那么今天我们让这里开始吧…</p><h2 id="5-copy-…"><a href="#5-copy-…" class="headerlink" title="5. copy(…)"></a>5. copy(…)</h2><p>我们可以使用控制台种提供全局方法 <code>copy</code> 将控制台内的所有可用内容复制到剪贴板中，这也包括我们在<a href="2018/12/06/apps/DevTools小技巧/day%201%20——%20控制台%20$/">上一篇</a>中介绍到的引用变量，比如: <code>copy(_$)</code> 或 <code>copy($0)</code><br><img src="/images/DevTools小技巧/2-1.gif" alt></p><h2 id="6-生成全局变量"><a href="#6-生成全局变量" class="headerlink" title="6. 生成全局变量"></a>6. 生成全局变量</h2><p>如果你有一些数据（比如你从你的程序中计算出来的一个数组）打印在控制台，并且你想要使用这部分数据做一些其他方面的工作，例如你想把这部分数据使用 <code>copy</code> 函数复制出来，你可以直接从控制台轻松将其作为全局变量使用。</p><p>你只需要右键打印出来的数据，并且选择 <code>Store as global variable</code> 选项。</p><p>首次使用这种方式存储，数据将会被复制给全局变量 <code>temp1</code>，其次是 <code>temp2</code>，以此类推，因此你可以多次使用存储多个值，且不需要担心会有变量被覆盖的风险。</p><p><img src="/images/DevTools小技巧/2-2.gif" alt></p><h2 id="7-保存错误堆栈跟踪信息"><a href="#7-保存错误堆栈跟踪信息" class="headerlink" title="7. 保存错误堆栈跟踪信息"></a>7. 保存错误堆栈跟踪信息</h2><p>堆栈跟踪信息对于你跟你的同事都很有用（例如：与其他前端开发人员或 QA 工程师一起工作）。<br>你可以将堆栈跟踪保存到文件中，从而抛弃截图的形式。<br><img src="/images/DevTools小技巧/2-3.gif" alt></p><h2 id="8-复制-HTML-文本-（快捷方式）"><a href="#8-复制-HTML-文本-（快捷方式）" class="headerlink" title="8. 复制 HTML 文本 （快捷方式）"></a>8. 复制 HTML 文本 （快捷方式）</h2><p>你可能知道可以右键单击或单击 html 元素旁边的省略号（•••）将其复制到操作系统剪贴板。</p><p>但你也可以使用 <code>[ctrl] + [c]</code> 快捷键（Mac 上的 <code>[⌘] + [c]</code> ）来实现同样的目的！🚀</p><p><img src="/images/DevTools小技巧/2-4.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tomsu/devtools-tips-day-2-copying-saving-6aa9bbdadbe21&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dev
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="DevTools" scheme="http://amu.fun/tags/DevTools/"/>
    
      <category term="文章翻译" scheme="http://amu.fun/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>DevTools 小技巧 day 1 —— 控制台 $</title>
    <link href="http://amu.fun/2018/12/06/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%201%20%E2%80%94%E2%80%94%20%E6%8E%A7%E5%88%B6%E5%8F%B0%20$/"/>
    <id>http://amu.fun/2018/12/06/apps/DevTools小技巧/day 1 —— 控制台 $/</id>
    <published>2018-12-06T07:53:27.000Z</published>
    <updated>2019-02-25T08:21:42.308Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://medium.com/@tomsu/devtools-tips-day-1-the-console-dollars-3aa0d93e923c" target="_blank" rel="noopener">DevTools tips — day 1: the console dollars</a></p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧，现在就让我们开始吧！</p><h2 id="1-0"><a href="#1-0" class="headerlink" title="1. $0"></a>1. <code>$0</code></h2><p><code>$0</code> 是对当前 Elements 面板中选定的 html 节点的引用<br><code>$1</code> 则是对上一次选定的节点的引用，<code>$2</code> 是对上上一次选定的引用，以此类推，最多可支持到 <code>$4</code><br>你可以使用这些引用变量来进行对用的操作（例如：<code>$1.appendChild($0)</code>）。<br><img src="/images/DevTools小技巧/1-1.gif" alt></p><h2 id="2-and"><a href="#2-and" class="headerlink" title="2. $ and $$"></a>2. <code>$ and $$</code></h2><p>控制台里的 <code>$</code> 是冗长方法 <code>document.querySelector</code> 的别名。<br>使用的前提条件是你的应用中没有声明 <code>$</code> 变量（例如： JQuery）。</p><p><code>$$</code>更是个省时利器了 🚀，它不仅会执行 <code>document.QuerySelectorAll</code> 方法，而且会将节点以数组的形式返回，而非 <code>NodeList</code> 类型。</p><p>通常情况下：<code>Array.from(document.querySelectorAll(&#39;div&#39;)) === $$(&#39;div&#39;)</code><br>超便捷有木有！！🚀<br><img src="/images/DevTools小技巧/1-2.gif" alt></p><h2 id="3"><a href="#3" class="headerlink" title="3. $_"></a>3. <code>$_</code></h2><p><code>$_</code> 是上一次计算的表达式结果的引用。<br><img src="/images/DevTools小技巧/1-3.png" alt></p><h2 id="4-i"><a href="#4-i" class="headerlink" title="4. $i"></a>4. <code>$i</code></h2><p>通过 Chrome 的 <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie" target="_blank" rel="noopener">Console Importer</a> 扩展程序，我们可以快捷的在控制台导入并使用 <code>npm</code>。<br>只需执行 <code>$i(&#39;lodash&#39;) or $i(&#39;moment&#39;)</code>，几秒之后 🕙，我们便可以获取到 <code>lodash/moment</code> 啦！</p><p><img src="/images/DevTools小技巧/1-4.gif" alt></p><p>以上就是今天到全部内容啦。Short and sweet.🍬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tomsu/devtools-tips-day-1-the-console-dollars-3aa0d93e923c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="DevTools" scheme="http://amu.fun/tags/DevTools/"/>
    
      <category term="文章翻译" scheme="http://amu.fun/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Web性能信息采集 — 高精度时间</title>
    <link href="http://amu.fun/2018/11/22/knowledge/performance/Web%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86%20%E2%80%94%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%97%B6%E9%97%B4/"/>
    <id>http://amu.fun/2018/11/22/knowledge/performance/Web性能信息采集 — 高精度时间/</id>
    <published>2018-11-22T02:09:27.000Z</published>
    <updated>2019-02-25T08:21:42.311Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://github.com/berwin/Blog/issues/25" target="_blank" rel="noopener">2018 你应该知道的 Web 性能信息采集指南</a> - 如何获得高精度的时间？</p></blockquote><hr><h3 id="如何获得高精度的时间（摘录）"><a href="#如何获得高精度的时间（摘录）" class="headerlink" title="如何获得高精度的时间（摘录）"></a>如何获得高精度的时间（摘录）</h3><p>ECMA-262 规范中定义了 <code>Date</code> 对象来表示自 1970 年 1 月 1 日以来的毫秒数。它足以满足大部分需求，但缺点是时间会受到时钟偏差与系统时钟调整的影响。时间的值不总是单调递增，后续值有可能会减少或者保持不变。</p><p>例如，下面这段代码计算出来的“<code>duration</code>”有可能被记录为正数、负数或零。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark_start = <span class="built_in">Date</span>.now();</span><br><span class="line">doTask(); <span class="comment">// Some task</span></span><br><span class="line"><span class="keyword">const</span> duration = <span class="built_in">Date</span>.now() - mark_start;</span><br></pre></td></tr></table></figure><p>上面这段代码获取的持续时间“duration”并不精准，它会受到时钟偏差与系统时钟调整的影响，所以最终得到的“duration”可能为正数、负数或零，我们根本不知道它记录的时间究竟是不是正确的时间。</p><p>高精度时间（High Resolution Time，简称<code>hr-time</code>）规范定义了<code>Performance</code>对象，通过<code>Performance</code>对象我们可以获得高精度的时间。</p><p><code>Performance</code>对象包含方法<code>now</code>和属性<code>timeOrigin</code>：</p><ul><li>方法<code>now</code>被执行后会返回从 <code>timeOrigin</code> 到现在的高精度时间。<blockquote><p><em>当前时间 - performance.timeOrigin</em></p></blockquote></li><li><p>属性<code>timeOrigin</code>返回<a href="https://html.spec.whatwg.org/multipage/browsers.html#creating-a-new-browsing-context" target="_blank" rel="noopener">页面浏览上下文第一次被创建</a>的时间。如果全局对象为<code>WorkerGlobalScope</code>，那么<code>timeOrigin</code>为 worker 被创建的时间。</p><blockquote><p>timeOrigin 的时间值不受时钟偏差与系统时钟调整的影响。</p></blockquote><p>例如，当<code>timeOrigin</code>的值被确定之后，无论将系统时间设置到什么时间，下面代码始终返回<code>timeOrigin</code>最初被赋予的时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(performance.timeOrigin).toLocaleString();</span><br><span class="line"><span class="comment">// 2018/8/6 上午11:41:58</span></span><br></pre></td></tr></table></figure></li></ul><p>如果两个时间值拥有相同的时间起源（<a href="https://w3c.github.io/hr-time/#dfn-time-origin" target="_blank" rel="noopener">Time Origin</a>），那么使用 <code>performance.now</code> 方法返回的任意两个按时间顺序记录的时间值之间的差值永远不可能是负数。</p><p>例如，下面这段代码计算出来的“<code>duration</code>”永远不可能为负数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark_start = performance.now();</span><br><span class="line">doTask(); <span class="comment">// Some task</span></span><br><span class="line"><span class="keyword">const</span> duration = performance.now() - mark_start;</span><br></pre></td></tr></table></figure><p>通过<code>performance.timeOrigin</code> + <code>performance.now</code> 可以得到精准的当前时间。该时间不受时钟偏差与系统时钟调整的影响。</p><blockquote><p>不受时钟偏差与系统时钟调整的影响指的是当<code>timeOrigin</code>的值被确定之后修改了系统时间，这时候<code>timeOrigin</code>不会受到影响。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeStamp = performance.timeOrigin + performance.now();</span><br><span class="line"><span class="built_in">console</span>.log(timeStamp); <span class="comment">// 1533539552977.5718</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp).toLocaleString();</span><br><span class="line"><span class="comment">// "2018/8/6 下午3:10:42"</span></span><br></pre></td></tr></table></figure><h3 id="场景使用"><a href="#场景使用" class="headerlink" title="场景使用"></a>场景使用</h3><p>高精度时间 <code>performance.now</code>，想到的场景使用有以下几个：</p><ol><li>可以用于微秒级动画的效果的使用上，具体使用方式可参考 <a href="/2017/06/22/knowledge/实现JavaScript动画序列播放/#performance-now-获取当前时间">实现 JavaScript 动画序列播放</a></li><li><code>Web端时钟</code>，获取服务器准确时间作为基准值，根据 <code>performance.now</code> 计算 <code>duration</code>，虽然有网络请求时间误差，但是可以避免受到系统时间调整带来的影响</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serverTime = (<span class="keyword">await</span> getServerTime()) - performance.now();</span><br><span class="line"><span class="keyword">let</span> nowTime;</span><br><span class="line">setInterval(</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">getRealTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nowTime = serverTime + performance.now();</span><br><span class="line">    <span class="keyword">return</span> getRealTime;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>活动/商品购买倒计时</code>，同第二点类似，均已服务器时间为基准值，计算距离结束时间的 <code>duration</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; serverStartTime, serverEndTime &#125; = <span class="keyword">await</span> getServerTime();</span><br><span class="line"><span class="keyword">const</span> nowTime = performance.now();</span><br><span class="line"><span class="keyword">const</span> serverDurationForNowToEnd = serverEndTime - serverStartTime;</span><br><span class="line"><span class="keyword">let</span> realDurationForNowToEnd = <span class="number">0</span>;</span><br><span class="line">setInterval(</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">getRealDuration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    realDurationForNowToEnd =</span><br><span class="line">      serverDurationForNowToEnd - performance.now() - nowTime;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/berwin/Blog/issues/25&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018 你应该知道的 Web 性能信息采集指南&lt;/a&gt; - 如何获得高精
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="http://amu.fun/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端防止页面调试方法</title>
    <link href="http://amu.fun/2018/08/16/knowledge/%E5%89%8D%E7%AB%AF%E9%98%B2%E6%AD%A2%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <id>http://amu.fun/2018/08/16/knowledge/前端防止页面调试方法/</id>
    <published>2018-08-16T02:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.312Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>使用 chrome 模拟器打开，会一直进入 debugger 模式</p></blockquote><hr><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> protection = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="string">''</span> + times / times)[<span class="string">'length'</span>] !== <span class="number">1</span> || times % <span class="number">20</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span><br><span class="line">    &#125;</span><br><span class="line">    loop(++times);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loop(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">protection();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 chrome 模拟器打开，会一直进入 debugger 模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;核心代码&quot;&gt;&lt;a href=&quot;#核心代码&quot; class=&quot;headerlink&quot; title=&quot;核心代码&quot;&gt;
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React - 组件类型</title>
    <link href="http://amu.fun/2017/08/30/knowledge/react/React%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    <id>http://amu.fun/2017/08/30/knowledge/react/React组件类型/</id>
    <published>2017-08-30T00:28:10.000Z</published>
    <updated>2019-02-25T08:21:42.312Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="http://mp.weixin.qq.com/s/U4REXWqmVa-XgyR1_fUf7A" target="_blank" rel="noopener">前端早读课 - 《【第 1042 期】React 之组件类型》</a> 读后总结</p></blockquote><hr><p>本文介绍了 <code>React</code> 当中有关组件的一系列概念:</p><ul><li>元素与组件 <code>Element</code> &amp; <code>Component</code></li><li>函数定义与类定义组件 <code>Functional</code> &amp; <code>Class</code></li><li>展示与容器组件 <code>Presentational</code> &amp; <code>Container</code></li><li>有状态与无状态组件 <code>Stateful</code> &amp; <code>Stateless</code></li><li>受控与非受控组件 <code>Controlled</code> &amp; <code>Uncontrolled</code></li><li>组合与继承 <code>Composition</code> &amp; <code>Inheritance</code></li></ul><h2 id="元素与组件-Element-amp-Component"><a href="#元素与组件-Element-amp-Component" class="headerlink" title="元素与组件 Element &amp; Component"></a>元素与组件 Element &amp; Component</h2><p>使用 <code>html element</code> 作为标签项的 <code>React DOM</code>，被称为 _元素_，元素是构建 React 应用的最小单位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line"><span class="comment">// 用JSX描述就相当于是调用React的方法创建了一个对象</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'Hello, world'</span>);</span><br></pre></td></tr></table></figure><p>React 官方对组件的定义，是指在 UI 界面中，可以被独立划分的、可复用的、独立的模块。其实就类似于 JS 当中对 <code>function</code> 函数的定义，它一般会接收一个名为 <code>props</code> 的输入，然后返回相应的 <code>React</code> 元素，再交给 <code>ReactDOM</code>，最后渲染到屏幕上。</p><h2 id="函数定义与类定义组件-Functional-amp-Class"><a href="#函数定义与类定义组件-Functional-amp-Class" class="headerlink" title="函数定义与类定义组件 Functional &amp; Class"></a>函数定义与类定义组件 Functional &amp; Class</h2><p>函数定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = <span class="function"><span class="params">props</span> =&gt;</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br></pre></td></tr></table></figure><p>类定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示与容器组件-Presentational-amp-Container"><a href="#展示与容器组件-Presentational-amp-Container" class="headerlink" title="展示与容器组件 Presentational &amp; Container"></a>展示与容器组件 Presentational &amp; Container</h2><p><em>展示组件：</em></p><ul><li>主要负责组件内容如何展示</li><li>从 <code>props</code> 接收父组件传递来的数据</li><li>大多数情况可以通过函数定义组件声明</li></ul><p><em>容器组件：</em></p><ul><li>主要关注组件数据如何交互</li><li>拥有自身的 <code>state</code>，从服务器获取数据，或与 <code>redux</code> 等其他数据处理模块协作</li><li>需要通过类定义组件声明，并包含生命周期函数和其他附加方法</li></ul><p>那么这样写具体有什么好处呢？</p><ul><li>解耦了界面和数据的逻辑</li><li>更好的可复用性，比如同一个回复列表展示组件可以套用不同数据源的容器组件</li><li>利于团队协作，一个人负责界面结构，一个人负责数据交互</li></ul><h2 id="有状态与无状态组件-Stateful-amp-Stateless"><a href="#有状态与无状态组件-Stateful-amp-Stateless" class="headerlink" title="有状态与无状态组件 Stateful &amp; Stateless"></a>有状态与无状态组件 Stateful &amp; Stateless</h2><p>有状态组件是指这个组件能够获取储存改变应用或组件本身的状态数据，在 <code>React</code> 当中也就是 <code>state</code>，一些比较明显的特征是我们可以在这样的组件当中看到对 <code>this.state</code> 的初始化，或 this.setState 方法的调用等等。而无状态组件一般只能看到对 <code>this.props</code> 的调用，大部分无状态组件都是函数定义组件</p><h2 id="受控与非受控组件-Controlled-amp-Uncontrolled"><a href="#受控与非受控组件-Controlled-amp-Uncontrolled" class="headerlink" title="受控与非受控组件 Controlled &amp; Uncontrolled"></a>受控与非受控组件 Controlled &amp; Uncontrolled</h2><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>一般涉及到表单元素时我们才会使用这种分类方法。受控组件的值由 <code>props</code> 或 <code>state</code> 传入，用户在元素上交互或输入内容会引起应用 <code>state</code> 的改变。在 <code>state</code> 改变之后重新渲染组件，我们才能在页面中看到元素中值的变化，假如组件没有绑定事件处理函数改变 <code>state</code>，用户的输入是不会起到任何效果的，这也就是 _受控_ 的含义所在。</p><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>类似于传统的 <code>DOM</code> 表单控件，用户输入不会直接引起应用 <code>state</code> 的变化，我们也不会直接为非受控组件传入值。想要获取非受控组件，我们需要使用一个特殊的 <code>ref</code> 属性，同样也可以使用 <code>defaultValue</code> 属性来为其指定一次性的默认值。</p><h2 id="组合与继承-Composition-amp-Inheritance"><a href="#组合与继承-Composition-amp-Inheritance" class="headerlink" title="组合与继承 Composition &amp; Inheritance"></a>组合与继承 Composition &amp; Inheritance</h2><p>即 <code>hoc</code>、<code>类继承</code> 的方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/U4REXWqmVa-XgyR1_fUf7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端早读课 - 《【第 1042 期】React 之组件类
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="React" scheme="http://amu.fun/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言精粹 - 函数篇(二)</title>
    <link href="http://amu.fun/2017/07/29/books/theGoodParts/3/"/>
    <id>http://amu.fun/2017/07/29/books/theGoodParts/3/</id>
    <published>2017-07-29T09:07:10.000Z</published>
    <updated>2019-02-25T08:21:42.310Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 函数篇(二)，高级篇</p></blockquote><hr><p>这篇文章我们将学习类型功能的扩展、递归的使用、闭包、级联、柯里化等函数的高级特性及用法</p><h2 id="扩展类型的功能-Augmenting-Types"><a href="#扩展类型的功能-Augmenting-Types" class="headerlink" title="扩展类型的功能(Augmenting Types)"></a>扩展类型的功能(Augmenting Types)</h2><p><code>JavaScript</code> 允许给 <em>基本类型</em> 扩充功能，在对象篇，我们了解到可以通过修改 <code>Object.prototype</code>, 使得所有对象都能继承到该改变。这样的方式对函数、数组、字符串、数字、正则和布尔值同样适用。<br>举例来说,我们可以通过 <code>Function.prototype</code> 增加方法来使得该方法对所有函数可用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototype[method] = func;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过给 <code>Function.prototype</code> 增加 <code>method</code> 方法，我们下次给对象增加方法的时候就不必键入 <code>prototype</code> 这几个字符，省掉了一些麻烦</p><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归(Recursion)"></a>递归(Recursion)</h2><p>递归函数就是会直接或间接地调用自身的一种函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔</span></span><br><span class="line"><span class="keyword">const</span> hanoi = <span class="function"><span class="keyword">function</span>(<span class="params">disc, src, aux, dst</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (disc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    hanoi(disc - <span class="number">1</span>, src, dst, aux);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Move disc <span class="subst">$&#123;disc&#125;</span> from <span class="subst">$&#123;src&#125;</span> to <span class="subst">$&#123;dst&#125;</span>`</span>);</span><br><span class="line">    hanoi(disc - <span class="number">1</span>, aux, src, dst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些语言提供了<code>尾递归</code>优化，这意味着如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，可显著提高速度，但 <code>JavaScript</code> 当前没有提供尾递归优化，深度递归的函数可能会因为堆栈溢出而运行失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个带尾递归的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">i, a = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> factorial(i - <span class="number">1</span>, a * i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">4</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><p>因为作用域的关系，函数可以访问它被创建时所处的上下文环境，上下文环境中的参数被函数使用时，该参数不会被销毁，并被函数直接访问，这种模式被称为 <code>闭包</code>，我们可以使用 <code>闭包</code> 的方式去封装一些私有属性、方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment(inc) &#123;</span><br><span class="line">      value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue() &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="级联-Cascade"><a href="#级联-Cascade" class="headerlink" title="级联(Cascade)"></a>级联(Cascade)</h2><p>如果我们让 _方法_ 返回返回 <code>this</code>，则可以实现 <code>级联</code>，即 <code>链式调用</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  increment(inc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  reduce(inc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value -= <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject</span><br><span class="line">  .increment(<span class="number">3</span>)</span><br><span class="line">  .reduce(<span class="number">2</span>)</span><br><span class="line">  .increment(<span class="number">1</span>)</span><br><span class="line">  .getValue(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h2><p><code>柯里化</code> 是函数式编程常用的方式，它允许我们把函数与传递给它的参数相结合，产生出一个新的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = add.curry(<span class="number">1</span>);</span><br><span class="line">add1(<span class="number">6</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 没有 <code>curry</code> 方法，但我们可以给 <code>Function.prototype</code> 扩充此功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.method(<span class="string">'curry'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的this指向函数自身</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.apply(<span class="literal">null</span>, args.concat(args2));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="记忆-Memoization"><a href="#记忆-Memoization" class="headerlink" title="记忆(Memoization)"></a>记忆(Memoization)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 语言精粹 - 函数篇(二)，高级篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这篇文章我们将学习类型功能的扩展、递归的使用、闭包、级联、柯里化等函数的高级特性及用法&lt;/p&gt;
&lt;h2 id=&quot;扩展类型的功能-
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://amu.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://amu.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言精粹 - 函数篇(一)</title>
    <link href="http://amu.fun/2017/07/28/books/theGoodParts/2/"/>
    <id>http://amu.fun/2017/07/28/books/theGoodParts/2/</id>
    <published>2017-07-28T06:57:27.000Z</published>
    <updated>2019-02-25T08:21:42.309Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 函数篇(一),基础篇</p></blockquote><hr><h2 id="函数对象-Function-Objects"><a href="#函数对象-Function-Objects" class="headerlink" title="函数对象(Function Objects)"></a>函数对象(Function Objects)</h2><p><code>JavaScript</code> 中的函数即是对象,对象字面量产生的对象连接到 <code>Object.prototype</code>,函数对象连接到 <code>Function.prototype</code> (该原型对象本身连接到 <code>Object.prototype</code>)，每个函数在创建时会附加两个隐藏属性： 函数的 <em>上下文</em> 和 <em>实现函数行为的代码</em>(调用函数时即调用该 <code>调用</code> 属性)<br>每个函数对象在创建时也随配有一个 <code>prototype</code> 属性，它的值是一个拥有 <code>constructor</code> 属性且值为该函数的对象<br>函数的与众不同之处在于它们可以被调用</p><h2 id="调用-Invocation"><a href="#调用-Invocation" class="headerlink" title="调用(Invocation)"></a>调用(Invocation)</h2><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数: <code>this</code> 和 <code>arguments</code>。参数 <code>this</code> 在面向对象编程中非常重要，它的值取决于调用的模式。在 <code>JavaScript</code> 中一共有 _4_ 中调用模式:<code>方法调用</code>、<code>函数调用</code>、<code>构造器调用</code> 和 <code>apply 调用</code>。这些模式在如何初始化关键参数 <code>this</code> 上存在差异</p><h3 id="方法调用模式-The-Method-Invocation-Pattern"><a href="#方法调用模式-The-Method-Invocation-Pattern" class="headerlink" title="方法调用模式(The Method Invocation Pattern)"></a>方法调用模式(The Method Invocation Pattern)</h3><p>当一个函数被保存为对象的一个属性时，我们称它为一个 <code>方法</code>。当一个方法被调用时，<code>this</code> 被绑定到该对象，如果调用表达式包含一个 <em>提取属性</em> 的动作(即包含一个 <code>.</code> 点表达式或 <code>[subscript]</code> 下标表达式),那么它就是被当做一个方法来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params">inc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += typeOf inc === <span class="string">'number'</span> ? inc : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment()</span><br><span class="line">myObject.value <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">2</span>)</span><br><span class="line">myObject.value <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>方法可以使用 <code>this</code> 访问自己所属的对象，<code>this</code> 到对象的绑定发生在 _调用_ 的时候，这个”超级”延迟绑定(<code>vary late binding</code>) 使得函数可以对 <code>this</code> 高度复用。通过 <code>this</code> 可取得它们所属对象的上下文的方法称为公共方法(<code>public method</code>)。</p><h3 id="函数调用模式-The-Function-Invocation-Pattern"><a href="#函数调用模式-The-Function-Invocation-Pattern" class="headerlink" title="函数调用模式(The Function Invocation Pattern)"></a>函数调用模式(The Function Invocation Pattern)</h3><p>当一个函数并非一个对象的属性时，那么它将被当做一个函数来调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 函数将返回两个传入参数的相加值</span></span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>通过该模式调用函数时，<code>this</code> 被绑定到全局对象。<em>这是语言设计上的一个错误</em>。倘若语言设计正确，那么当内部函数被调用时，<code>this</code> 应该仍然绑定到外部函数的 <code>this</code> 变量。这个设计错误的后果就是方法不能利用内部函数来帮助它工作，因为内部函数的 <code>this</code> 被绑定了错误的值，所以不能共享该方法对对象的访问权。幸运的是，有一个很容易的解决方案：如果该方法定义一个变量并给它赋值为 <code>this</code>,那么内部函数就可以通过那个变量访问到 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myObject.double = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.value = add(that.value, that.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  helper();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.double();</span><br><span class="line">myObject.value; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="构造器调用模式-The-Constructor-Invocation-Pattern"><a href="#构造器调用模式-The-Constructor-Invocation-Pattern" class="headerlink" title="构造器调用模式(The Constructor Invocation Pattern)"></a>构造器调用模式(The Constructor Invocation Pattern)</h3><p>如果在一个函数前面带上 <code>new</code> 来调用，那么背地里将会创建一个连接到该函数的 <code>prototype</code> 成员的新对象，同时 <code>this</code> 会被绑定到那个新对象上<br><code>new</code> 前缀也会改变 <code>return</code> 语句的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数对象在创建时也随配有一个 `prototype` 属性，它的值是一个拥有 `constructor` 属性且值为该函数的对象</span></span><br><span class="line"><span class="keyword">const</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.status = string;</span><br><span class="line">&#125;;</span><br><span class="line">Quo.prototype.get_status = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 Quo 实例</span></span><br><span class="line"><span class="keyword">const</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">'confused'</span>);</span><br><span class="line">myQuo.get_status(); <span class="comment">// 'confused'</span></span><br></pre></td></tr></table></figure><p>该调用模式调用的函数被称为 <code>构造器函数</code>,一般约定以 <em>首字母大写</em> 的命名方式命名，但是这种形式的构造器函数并不推荐，我们将在后续的学习中学习到更优的替代方式</p><h3 id="Apply-调用模式-The-Apply-Invocation-Pattern"><a href="#Apply-调用模式-The-Apply-Invocation-Pattern" class="headerlink" title="Apply 调用模式(The Apply Invocation Pattern)"></a>Apply 调用模式(The Apply Invocation Pattern)</h3><p><code>JavaScript</code> 是一门函数式的面向对象编程语言，即函数可以拥有自己的方法。<br><code>apply</code> 方法让我们构建一个参数数组传递给调用函数，它也允许我们选择 <code>this</code> 的值。<code>apply</code> 方法接受两个参数，第一个是要绑定给 <code>this</code> 的值，第二个是一个<code>参数数组</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = add.apply(<span class="literal">null</span>, array); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusObj = &#123;</span><br><span class="line">  status: <span class="string">'A-OK'</span></span><br><span class="line">&#125;;</span><br><span class="line">Quo.prototype.get_status.apply(statusObj); <span class="comment">// 'A-OK'</span></span><br></pre></td></tr></table></figure><h2 id="参数-Arguments"><a href="#参数-Arguments" class="headerlink" title="参数(Arguments)"></a>参数(Arguments)</h2><p>当函数被调用时，会得到一个“免费”配送的参数 —— <code>arguments</code>,它是一个类数组，用有一个 <code>length</code> 属性，但没有任何数组的方法，函数可以通过此参数访问所有它被调用时传递给它的参数列表:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>这不是一种特别有用的模式，之后我们将学习如何给数组添加一个相似的方法达到同样的效果。</p><h2 id="返回-Return"><a href="#返回-Return" class="headerlink" title="返回(Return)"></a>返回(Return)</h2><p>如果函数调用时在前面加上了 <code>new</code> 前缀，且返回值不是一个对象，则返回 <code>this</code> (该新对象)</p><p>下一篇文章我们将学习关于函数的一些较高级的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 语言精粹 - 函数篇(一),基础篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;函数对象-Function-Objects&quot;&gt;&lt;a href=&quot;#函数对象-Function-Objects&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://amu.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://amu.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言精粹 - 对象篇</title>
    <link href="http://amu.fun/2017/07/27/books/theGoodParts/1/"/>
    <id>http://amu.fun/2017/07/27/books/theGoodParts/1/</id>
    <published>2017-07-27T09:09:27.000Z</published>
    <updated>2019-02-25T08:21:42.309Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 对象篇</p></blockquote><hr><p><em>Javascript</em> 的简单数据类型包括数字、字符串、布尔值、<code>null</code> 和 <code>undefined</code>，其他所有的值都是 _对象_。数字、字符串和布尔值是 ‘<code>貌似</code>’ 对象，因为它们拥有方法，但它们是不可变的。<br><em>Javascript</em> 中的 _对象_ 是可变的键控集合( <code>keyed collections</code> ),在 <em>Javascript</em> 中，数组、函数、正则表达式都是对象<br>_对象_ 是 <code>属性</code> 的容器，其中每个属性都拥有名字<code>(key)</code>和值<code>(value)</code>，属性名可以是包括空字符串在内的任意字符串，属性值可以是除了 <code>undefined</code> 之外的任何值<br><em>Javascript</em> 包含一种 <em>原型链</em> 的特性，允许对象继承另一个对象的属性，正确使用能减少对象初始化时消耗的时间和内存</p><h2 id="对象字面量-Object-Literals"><a href="#对象字面量-Object-Literals" class="headerlink" title="对象字面量(Object Literals)"></a>对象字面量(Object Literals)</h2><p>在对象字面量中，如果属性名是一个合法的 <code>Javascript</code> 标识符且不是保留字，则并不强制要求用引号括住属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stooge = &#123;</span><br><span class="line">  <span class="string">'first-name'</span>: <span class="string">'Amu'</span>,</span><br><span class="line">  last_name: <span class="string">'Amu'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="检索-Retrieval"><a href="#检索-Retrieval" class="headerlink" title="检索(Retrieval)"></a>检索(Retrieval)</h2><p>尝试从 <code>undefined</code> 的成员属性中取值将会导致 <code>TypeError</code>,可通过 <code>&amp;&amp;</code> 运算符避免错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flight = &#123;&#125;;</span><br><span class="line">flight.equipment; <span class="comment">// undefined</span></span><br><span class="line">flight.equipment.model; <span class="comment">// throw 'TypeError'</span></span><br><span class="line">flight.equipment &amp;&amp; flight.equipment.model; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="更新-Update"><a href="#更新-Update" class="headerlink" title="更新(Update)"></a>更新(Update)</h2><p>对象里的值可以通过赋值语句更新，如果属性名(<code>key</code>)存在，则属性值会被替换，否则该属性会被扩充到对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stooge[<span class="string">'first-name'</span>] = <span class="string">'Gu'</span>;</span><br><span class="line">stooge[<span class="string">'middle-name'</span>] = <span class="string">'Amu'</span>;</span><br></pre></td></tr></table></figure><h2 id="引用-Reference"><a href="#引用-Reference" class="headerlink" title="引用(Reference)"></a>引用(Reference)</h2><p>对象通过引用来传递，它们永远不会被复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = stooge;</span><br><span class="line">x.nickName = <span class="string">'Amu'</span>;</span><br><span class="line"><span class="comment">// 因为 x 和 stooge 是指向同一个对象的引用，所以 stooge.nickName 为 Amu</span></span><br><span class="line">stooge.nickName; <span class="comment">// Amu</span></span><br></pre></td></tr></table></figure><h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a>原型(Prototype)</h2><p>每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到 <code>Object.prototype</code>,它是 <code>JavaScript</code> 中的标配对象。<br>当你创建一个新对象时，你可以选择某个对象作为它的原型(<code>Object.create</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟Object.create</span></span><br><span class="line"><span class="keyword">if</span> (typeOf <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = o</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型链接在更新时不起作用，当我们对某个对象作出改变时，不会触及该对象的原型属性:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> another_stooge = <span class="built_in">Object</span>.create(stooge);</span><br><span class="line">another_stooge.nickName = <span class="string">'Ruby'</span>;</span><br><span class="line">stooge.nickName; <span class="comment">// 'Amu'</span></span><br></pre></td></tr></table></figure><p>原型关系是一种动态的关系，如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stooge.prefession = <span class="string">'coder'</span>;</span><br><span class="line">another_stooge.prefession; <span class="comment">// 'coder'</span></span><br></pre></td></tr></table></figure><h2 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h2><p><code>hasOwnProperty</code> 可以检查对象自身信息，如果对象拥有独有的属性，它将返回 <code>true</code>,<code>hasOwnProperty</code> 方法不会检查原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">another_stooge.hasOwnProperty(<span class="string">'nickName'</span>); <span class="comment">// true</span></span><br><span class="line">another_stooge.hasOwnProperty(<span class="string">'first-name'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="枚举-Enumeration"><a href="#枚举-Enumeration" class="headerlink" title="枚举(Enumeration)"></a>枚举(Enumeration)</h2><p><code>for in</code> 语句可用来遍历一个对象中的所有属性名.该枚举过程将会列出所有的属性 —— 包括函数和你可能不关心的原型中的属性，所以有必要过滤掉你不想要的值，最为常用的过滤器是 <code>hasOwnProperty</code> 方法，以及使用 <code>typeOf</code> 来排除函数，还有一种创建 <code>纯对象</code> 的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pureObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">pureObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>for in</code> 是无序的，如果需要正确顺序读取属性值，可以创建一个数组缓存属性名，然后按顺序遍历数组去读取对象属性值</p><h2 id="删除-Delete"><a href="#删除-Delete" class="headerlink" title="删除(Delete)"></a>删除(Delete)</h2><p><code>delete</code> 运算符用来删除对象的属性，如果对象包含该属性，则将其移除，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型中的属性透露出来:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">another_stooge.nickName; <span class="comment">// 'Ruby'</span></span><br><span class="line"><span class="keyword">delete</span> another_stooge.nickName;</span><br><span class="line">another_stooge.nickName; <span class="comment">// 'Amu',来自 stooge.nickName</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 语言精粹 - 对象篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Javascript&lt;/em&gt; 的简单数据类型包括数字、字符串、布尔值、&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undef
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://amu.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://amu.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>单向链表 - Linked list(一)</title>
    <link href="http://amu.fun/2017/07/25/algorithm/linkedList1/"/>
    <id>http://amu.fun/2017/07/25/algorithm/linkedList1/</id>
    <published>2017-07-25T07:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.307Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现单向链表类</p></blockquote><hr><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展示了一个链表的结构<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" alt="单向链表"><br>相对传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素</p><h3 id="单向链表的创建"><a href="#单向链表的创建" class="headerlink" title="单向链表的创建"></a>单向链表的创建</h3><p>我们将创建一个类来表示单向链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向列表尾部添加一个新的项</span></span><br><span class="line">  append(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="keyword">this</span>.Node(element);</span><br><span class="line">    <span class="keyword">if</span> (!currentNode) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表中移除特定位置的元素</span></span><br><span class="line">  removeAt(position) &#123;</span><br><span class="line">    <span class="comment">// 判断position的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = currentNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    this.length--;</span><br><span class="line">    return currentNode.element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在任意位置插入一个元素</span><br><span class="line">  insert(position, element) &#123;</span><br><span class="line">    // 判断position的合法性</span><br><span class="line">    if (position &lt; 0 || position &gt; this.length) return false;</span><br><span class="line">    let index = 0;</span><br><span class="line">    let previousNode = null;</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line">    const node = new this.Node(element);</span><br><span class="line">    if (position === 0) &#123;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      this.head = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      previousNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    this.length++;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回传入元素的位置</span><br><span class="line">  indexOf(element) &#123;</span><br><span class="line">    let index = 0;</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line"></span><br><span class="line">    while (currentNode) &#123;</span><br><span class="line">      if (currentNode.element === element) &#123;</span><br><span class="line">        return index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 移除特定元素</span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    const index = this.indexOf(element);</span><br><span class="line">    return this.removeAt(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将单向链表转换为一个数组</span><br><span class="line">  toArray() &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line">    while (currentNode) &#123;</span><br><span class="line">      arr.push(currentNode.element);</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 清空链表</span><br><span class="line">  clear() &#123;</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将单向链表转换为一个字符串</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.toArray().toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表是否为空</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.length === 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表长度</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表head</span><br><span class="line">  getHead() &#123;</span><br><span class="line">    return this.head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Javascript 实现单向链表类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指
      
    
    </summary>
    
      <category term="算法" scheme="http://amu.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://amu.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>队列 - queue</title>
    <link href="http://amu.fun/2017/07/23/algorithm/queue/"/>
    <id>http://amu.fun/2017/07/23/algorithm/queue/</id>
    <published>2017-07-23T03:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.307Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现队列类</p></blockquote><hr><p>_队列_ 是遵循 <em>先进先出(FIFO)</em> 原则的一组有序的项，队列在尾部添加新元素，并从顶部移除元素，最新添加的元素必须排在队列的末尾</p><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><p>我们将创建一个类来表示队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加一个(或多个)新的项</span></span><br><span class="line">  enqueue(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列中的第一项,并返回移除的元素</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列中的第一个元素</span></span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断队列是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列里的所有元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出items元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列的创建"><a href="#优先队列的创建" class="headerlink" title="优先队列的创建"></a>优先队列的创建</h3><p>优先队列想比较于普通队列，它的每个元素均有一个优先权值，权值越大，优先级越前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  enqueue(element, priority) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items, isEmpty, size &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> items.push(&#123; element, priority &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priority &lt; items[i].priority) &#123;</span><br><span class="line">        <span class="keyword">return</span> items.splice(i, <span class="number">0</span>, &#123; element, priority &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    items.push(&#123; element, priority &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法和普通Queue实现相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Javascript 实现队列类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;_队列_ 是遵循 &lt;em&gt;先进先出(FIFO)&lt;/em&gt; 原则的一组有序的项，队列在尾部添加新元素，并从顶部移除元素，最新添加的元素必须排在队列的
      
    
    </summary>
    
      <category term="算法" scheme="http://amu.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://amu.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈 - stack</title>
    <link href="http://amu.fun/2017/07/22/algorithm/stack/"/>
    <id>http://amu.fun/2017/07/22/algorithm/stack/</id>
    <published>2017-07-22T03:10:32.000Z</published>
    <updated>2019-02-25T08:21:42.307Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现栈类</p></blockquote><hr><p>_栈_ 是一种遵从 <em>后进先出(LIFO)</em> 原则的有序集合，新添加的或待删除的元素都保存在栈的末尾，称作 _栈顶_，另一端就叫 _栈底_，在栈里，新元素都靠近栈顶，旧元素都靠近栈底。</p><h3 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h3><p>我们将创建一个类来表示栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加一个(或几个)新元素到栈顶</span></span><br><span class="line">  push(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈顶元素，同时返回被移除的元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶的元素内容</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出items元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制转化为其他进制"><a href="#将十进制转化为其他进制" class="headerlink" title="将十进制转化为其他进制"></a>将十进制转化为其他进制</h3><p>创建了 <code>Stack</code> 类，让我们用其写一个小 demo，写一个将十进制转为其他进制的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNum, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rem = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> baseString = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> digits = <span class="string">'0123456789ABCDEF'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (decNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(decNum % base);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    decNum = <span class="built_in">Math</span>.floor(decNum / base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[remStack.pop()];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Javascript 实现栈类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;_栈_ 是一种遵从 &lt;em&gt;后进先出(LIFO)&lt;/em&gt; 原则的有序集合，新添加的或待删除的元素都保存在栈的末尾，称作 _栈顶_，另一端就叫 _栈
      
    
    </summary>
    
      <category term="算法" scheme="http://amu.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://amu.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>VueJs - 高阶组件实践</title>
    <link href="http://amu.fun/2017/07/06/knowledge/vue/vuejs%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
    <id>http://amu.fun/2017/07/06/knowledge/vue/vuejs高阶组件实践/</id>
    <published>2017-07-06T07:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.312Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>VueJs - 高阶组件实践</p></blockquote><hr><h3 id="Higher-Order-Components-hoc"><a href="#Higher-Order-Components-hoc" class="headerlink" title="Higher-Order Components (hoc)"></a>Higher-Order Components (hoc)</h3><p><a href="https://facebook.github.io/react/docs/higher-order-components.html" target="_blank" rel="noopener">Higher-Order Components</a> 高阶组件是 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 的一种高级应用，确切的说，高阶组件其实只是一个方法( <code>function</code> )，它接受一个组件，处理并返回另一个新组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>探讨前我们先理下需求，在 <code>组件化</code> 开发中，我们往往会遇到这样一种情况：完全不同的两个组件，可能会需要拥有一个或 N 个相同的功能，我们以 <code>input number</code> 为例，在按钮点击时我们需要让其 <code>console</code> 当前按钮的 <code>counter data</code>，并在按钮前面加上 <code>hoc-</code> 的字眼，这时我们有两种选择：</p><ol><li>直接新建一个按钮组件，让其包含以上功能</li><li>使用 <code>hoc</code> 函数处理组件，并返回新组件供使用</li></ol><p>为遵循 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY (Don’t repeat yourself)</a> 规则，我们选择 <code>hoc</code> 来实现改需求</p><h3 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add-btn.js</span></span><br><span class="line">&lt;template lang=<span class="string">"html"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"add-btn"</span> @click=<span class="string">"handleClick"</span>&gt;add: &#123;&#123;counter&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'add-btn'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter++</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce-btn.js</span></span><br><span class="line">&lt;template lang=<span class="string">"html"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"reduce-btn"</span> @click=<span class="string">"handleClick"</span>&gt;reduce: &#123;&#123;counter&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'reduce-btn'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter--</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HOC-实践"><a href="#HOC-实践" class="headerlink" title="HOC 实践"></a>HOC 实践</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'hoc'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...container.props</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      container</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleChange(data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, data);</span><br><span class="line">        <span class="keyword">const</span> &#123; $options, counter &#125; = <span class="keyword">this</span>.$children[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`%s's counter is %d`</span>, $options.name, counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = &#123;</span><br><span class="line">        props: <span class="keyword">this</span>.$props</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          hoc-</span><br><span class="line">          &lt;container onChange=&#123;<span class="keyword">this</span>.handleChange&#125; &#123;...data&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;add-btn @change=<span class="string">"handleChange"</span> a=<span class="string">"b"</span>/&gt;</span><br><span class="line">    &lt;reduce-btn @change=<span class="string">"handleChange"</span>/&gt;</span><br><span class="line">    &lt;div&gt;total: &#123;&#123;total&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import hoc from './</span>hoc.js<span class="string">'</span></span><br><span class="line"><span class="string">import AddBtn from '</span>./AddBtn.vue<span class="string">'</span></span><br><span class="line"><span class="string">import ReduceBtn from '</span>./ReduceBtn.vue<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: '</span>app<span class="string">',</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    '</span>add-btn<span class="string">': hoc(AddBtn),</span></span><br><span class="line"><span class="string">    '</span>reduce-btn<span class="string">': hoc(ReduceBtn)</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      total: 0</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    handleChange (number) &#123;</span></span><br><span class="line"><span class="string">      this.total += number</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;VueJs - 高阶组件实践&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Higher-Order-Components-hoc&quot;&gt;&lt;a href=&quot;#Higher-Order-Components-hoc&quot; class
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://amu.fun/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 官方教程总结</title>
    <link href="http://amu.fun/2017/06/30/apps/Emacs%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://amu.fun/2017/06/30/apps/Emacs官方教程总结/</id>
    <published>2017-06-30T07:53:27.000Z</published>
    <updated>2019-02-25T08:21:42.309Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Emacs 官方教程总结</p></blockquote><hr><h3 id="读官方教程"><a href="#读官方教程" class="headerlink" title="读官方教程"></a>读官方教程</h3><p>按以下步骤阅读教程:</p><ul><li>不安装任何插件打开 <code>Emacs</code>, 比如在 <code>Shell</code> 中运行命令 <code>emacs -nw -Q</code></li><li>同时按下 <code>Alt</code> 和 <code>X</code> 健, 输入 <code>help-with-tutorial</code> (类似快捷键后文简写为 <code>M-x help-with-tutorial</code> 代替), 回车</li></ul><h3 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h3><ul><li><code>C</code> 表示按下 <code>Ctrl</code> 键, <code>M</code> 表示按下 <code>Alt</code> 键</li><li><code>M-x my-command</code> 表示同时按下 <code>Alt</code> 和 <code>X</code>, 输入 “my-command”, 然后回车</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="翻页浏览"><a href="#翻页浏览" class="headerlink" title="翻页浏览"></a>翻页浏览</h4><ul><li><code>C-v</code> 向前移动一屏</li><li><code>M-v</code> 向后移动一屏</li><li><code>C-l</code> 重绘屏幕，并将光标所在行置于屏幕的中央</li></ul><h4 id="基本的光标控制（BASIC-CURSOR-CONTROL）"><a href="#基本的光标控制（BASIC-CURSOR-CONTROL）" class="headerlink" title="基本的光标控制（BASIC CURSOR CONTROL）"></a>基本的光标控制（BASIC CURSOR CONTROL）</h4><ul><li>C-f(forward) 向右移动一个字符</li><li>C-b(backward) 向左移动一个字符</li><li>M-f 向右移动一个词【对中文是移动到下一个标点符号】</li><li>M-b 向左移动一个词【对中文是移动到上一个标点符号】</li><li>C-n(next) 移动到下一行</li><li>C-p(previous) 移动到上一行</li><li>C-a 移动到行首</li><li>C-e 移动到行尾</li><li>M-a 移动到句首</li><li>M-e 移动到句尾</li><li>M-&lt; 移动到文本开头</li><li>M-&gt; 移动到文本末尾</li></ul><p>使用这些命令而不使用方向键进行光标移动的理由是：</p><ul><li>它们在任何键盘上都能用</li><li>当你熟练使用 Emacs 之后，你会发现用这些组合键比用方向键要快得多，因为你<br>的手不需要离开打字区</li><li>一旦你习惯了使用这些组合键，你也可以很容易地适应其它更高级的光标移动命令</li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul><li><code>C-u 8 C-f</code> 会向前移动 8 个字符</li></ul><h4 id="在-EMACS-失去响应的时候（WHEN-EMACS-IS-HUNG）"><a href="#在-EMACS-失去响应的时候（WHEN-EMACS-IS-HUNG）" class="headerlink" title="在 EMACS 失去响应的时候（WHEN EMACS IS HUNG）"></a>在 EMACS 失去响应的时候（WHEN EMACS IS HUNG）</h4><ul><li><code>C-g</code> 终止命令</li></ul><h4 id="插入与删除（INSERTING-AND-DELETING）"><a href="#插入与删除（INSERTING-AND-DELETING）" class="headerlink" title="插入与删除（INSERTING AND DELETING）"></a>插入与删除（INSERTING AND DELETING）</h4><ul><li>C-u 次数 字符 重复输入多少次的相同字符</li><li>backspace 删除光标前的一个字符</li><li>C-d 删除光标后的一个字符</li><li>M-backspace 移除光标前的一个词</li><li>M-d 移除光标后的一个词</li><li>C-k 移除光标到行尾间的字符</li><li>M-k 移除光标到句尾间的字符</li><li>C-@ 移动光标选择要删除的文本</li><li>C-w 剪切选中文本</li><li>M-w 拷贝选中的文本</li><li>C-g 取消选择</li><li>C-x h 全选</li><li>C-w 剪切选中文本</li><li>M-w 拷贝选中的文本</li><li>被移除的可以被重新插入在任何位置，被删除的只能撤销删除。</li><li>C-y 在光标处插入最后移除的文字</li><li>M-y 召回再前一次移除的文字</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Emacs 官方教程总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;读官方教程&quot;&gt;&lt;a href=&quot;#读官方教程&quot; class=&quot;headerlink&quot; title=&quot;读官方教程&quot;&gt;&lt;/a&gt;读官方教程&lt;/h3&gt;&lt;p&gt;按
      
    
    </summary>
    
      <category term="效率神器" scheme="http://amu.fun/categories/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="Emacs" scheme="http://amu.fun/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>实现JavaScript动画序列播放</title>
    <link href="http://amu.fun/2017/06/22/knowledge/%E5%AE%9E%E7%8E%B0JavaScript%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97%E6%92%AD%E6%94%BE/"/>
    <id>http://amu.fun/2017/06/22/knowledge/实现JavaScript动画序列播放/</id>
    <published>2017-06-22T09:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.313Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/sixty-lines-of-code-animation.html" target="_blank" rel="noopener">《用 65 行代码实现 JavaScript 动画序列播放》</a> 读后总结</p></blockquote><hr><h3 id="performance-now-获取当前时间"><a href="#performance-now-获取当前时间" class="headerlink" title="performance.now() 获取当前时间"></a>performance.now() 获取当前时间</h3><p>在新的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a> 规范中，<code>frame</code> 回调的参数 <code>timestamp</code> 是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">DOMHighResTimeStamp</a> 对象，它比 <code>Date</code> 的计时要更精确（可以精确到纳秒）。因此获取时间我们优先使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" target="_blank" rel="noopener">performance.now()</a>，如果浏览器不支持 <code>performance.now()</code>，我们再降级使用 <code>Date.now()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nowtime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> performance !== <span class="string">'undefined'</span> &amp;&amp; performance.now) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now ? <span class="built_in">Date</span>.now() : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requestAnimationFrame-polyfill"><a href="#requestAnimationFrame-polyfill" class="headerlink" title="requestAnimationFrame polyfill"></a>requestAnimationFrame polyfill</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.requestAnimationFrame === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//polyfill</span></span><br><span class="line">      <span class="keyword">this</span>::callback(nowtime());</span><br><span class="line">    &#125;, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">qId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clearTimeout(qId);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Animator-ES6-实现"><a href="#Animator-ES6-实现" class="headerlink" title="Animator ES6 实现"></a>Animator ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(duration, update, easing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    <span class="keyword">this</span>.update = update;</span><br><span class="line">    <span class="keyword">this</span>.easing = easing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; duration, update, easing &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> qId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        startTime = startTime || timestamp;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">Math</span>.min(<span class="number">1.0</span>, (timestamp - startTime) / duration);</span><br><span class="line"></span><br><span class="line">        self::update(easing ? easing(p) : p, p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">          qId = requestAnimationFrame(step);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(self);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        cancelAnimationFrame(qId);</span><br><span class="line">        self::update(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        reject(<span class="string">'User canceled!'</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      qId = requestAnimationFrame(step);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 能够传入新的 easing，并返回新的 Animator 对象，这样我们就可以在原动画的基础上扩展我们的动画效果</span></span><br><span class="line">  ease = <span class="function"><span class="params">easing</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Animator(<span class="keyword">this</span>.duration, <span class="keyword">this</span>.update, easing);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.h5jun.com/post/sixty-lines-of-code-animation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《用 65 行代码实现 Java
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="动画" scheme="http://amu.fun/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>JS动画基础案例</title>
    <link href="http://amu.fun/2017/06/21/knowledge/JS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/"/>
    <id>http://amu.fun/2017/06/21/knowledge/JS动画基础案例/</id>
    <published>2017-06-21T02:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.310Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a> 学习笔记，将以 ES6 的语法实现原文案例</p></blockquote><hr><h3 id="动画的简易封装"><a href="#动画的简易封装" class="headerlink" title="动画的简易封装"></a>动画的简易封装</h3><p>为了实现更加复杂的动画，我们可以将动画进行简易的封装，要进行封装，我们先要抽象出动画相关的要素：</p><ul><li>动画时长：\(T = duration\)</li><li>动画进程：\( p = \frac{t}{T}\ (p \in [0, 1])\)</li><li>动画量子 easing：\(e = f(p)\)</li><li>动画方程：\([x, y] = G(e) = G(f(p))\)</li><li>动画生命周期：开始、进行中、结束。</li></ul><p><em>动画的简易封装</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param  &#123;Number&#125;   duration 动画持续时间</span></span><br><span class="line"><span class="comment">   * @param  &#123;Function&#125; progress 过程处理函数，回调参数为 动画量子easing 及 动画进度 p</span></span><br><span class="line"><span class="comment">   * @param  &#123;Function&#125; easing   easing处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(duration, progress, easing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    <span class="keyword">this</span>.progress = progress;</span><br><span class="line">    <span class="keyword">this</span>.easing =</span><br><span class="line">      easing ||</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">this</span>.rAF = <span class="built_in">window</span>.requestAnimationFrame; <span class="comment">// rAF 需要做兼容性判断</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start = <span class="function"><span class="params">finished</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> &#123; duration, progress, easing, rAF &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    rAF(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 记录动画进度</span></span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">Date</span>.now() - startTime) / duration;</span><br><span class="line">      <span class="keyword">let</span> next = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据进度及finished参数，选择不同的 progress 回调方式，回调参数为 动画量子easing 及 动画进度 p</span></span><br><span class="line">      <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        progress(easing(p), p);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> finished === <span class="string">'function'</span>) &#123;</span><br><span class="line">          next = finished() === <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next = finished === <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next) &#123;</span><br><span class="line">          progress(easing(<span class="number">1.0</span>), <span class="number">1.0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          startTime += duration;</span><br><span class="line">          progress(easing(p), p);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否继续执行定时器</span></span><br><span class="line">      <span class="keyword">if</span> (next) rAF(step);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码里，我们封装出一个简易的动画类 <code>Animator</code>, 这个类的构造器接收三个参数，分别是 <code>duration</code>, <code>process</code> 和 <code>easing</code>。它产生一个对象，包含一个 <code>start</code> 方法，这个方法用指定 <code>duration</code>、<code>process</code> 和 <code>easing</code> 执行动画。<br><code>start</code> 方法包含一个参数，这个参数是一个布尔类型或者回调函数，当动画结束的时候，如果这个参数是回调函数，将执行这个函数，它的返回值如果不是 <code>false</code> 那么结束动画，否则循环播放动画。</p><h3 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h3><p>在构造更复杂的动画的时候，为了更方便使用，避免回调嵌套，我们可以再实现一个动画队列类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(animators) &#123;</span><br><span class="line">    <span class="keyword">this</span>.animators = animators || [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  append = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.animators.push(...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  flush = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; animators &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> animator = animators.shift();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animator <span class="keyword">instanceof</span> Animator) &#123;</span><br><span class="line">          animator.start(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">              play();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          self::animator();</span><br><span class="line">          <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">            play();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      play();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础案例"><a href="#基础案例" class="headerlink" title="基础案例"></a>基础案例</h3><p>我们尝试使用上面设计的动画类来构造连续播放的动画：</p><p><a href="https://jsfiddle.net/Amu_xh/3uvpLj2z/2/" target="_blank" rel="noopener">让滑块先向右然后再向下运动</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;tx&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translate(100px, <span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  a1.start(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    a2.start();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/Amu_xh/q8fycj2p/" target="_blank" rel="noopener">让滑块沿一个矩形边界运动</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;tx&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translate(100px, <span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * (<span class="number">1</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translate(<span class="subst">$&#123;tx&#125;</span>px, 100px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a4 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * (<span class="number">1</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line">  animators.append(a1, a2, a3, a4);</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意到我们的动画队列除了支持 Animator 对象外，还支持普通的函数，因此我们可以组合起来做一些复杂的运动：<br><a href="https://jsfiddle.net/Amu_xh/41Lwknxs/" target="_blank" rel="noopener">弹跳的小球</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1414</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">200</span> * p * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1414</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">200</span> - <span class="number">200</span> * p * (<span class="number">2</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line">  animators.append(a1, a2, <span class="function"><span class="keyword">function</span> <span class="title">a3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.append(a1, a2, a3);</span><br><span class="line">  &#125;);</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以再加入更复杂的效果：<br>[弹跳的小球 - 带阻尼效果]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> T = <span class="number">1414</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(T, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = (<span class="keyword">this</span>.duration * <span class="number">200</span>) / T;</span><br><span class="line">  <span class="keyword">const</span> ty = s * (p * p - <span class="number">1</span>);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(T, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = (<span class="keyword">this</span>.duration * <span class="number">200</span>) / T;</span><br><span class="line">  <span class="keyword">const</span> ty = -s * p * (<span class="number">2</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a2.duration *= <span class="number">0.7</span>;</span><br><span class="line">  <span class="keyword">if</span> (a2.duration &lt;= <span class="number">0.0001</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    animators.animators.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animators.append(a1, foo, a2, <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a1.duration *= <span class="number">0.7</span>;</span><br><span class="line">  <span class="keyword">this</span>.append(a1, foo, a2, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
      <category term="动画" scheme="http://amu.fun/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于动画，你需要知道</title>
    <link href="http://amu.fun/2017/06/20/knowledge/%E5%85%B3%E4%BA%8E%E5%8A%A8%E7%94%BB%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/"/>
    <id>http://amu.fun/2017/06/20/knowledge/关于动画你需要知道的/</id>
    <published>2017-06-20T02:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.312Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a> 读后总结</p></blockquote><hr><h3 id="简单的-JS-动画"><a href="#简单的-JS-动画" class="headerlink" title="简单的 JS 动画"></a>简单的 JS 动画</h3><p>在浏览器里，动画实现的基本原理非常简单明了，其实就是 <em>采用定时器改变显示元素的一些属性的过程</em>。不管是 JavaScript 操作 DOM 的动画，还是 CSS3 动画，还是 Canvas 动画，或者 SVG 动画，区别只是使用的 API、何种定时器，影响什么环境（DOM/Canvas/SVG/WebGL）。</p><p><a class="jsbin-embed" href="//code.h5jun.com/wev/6/embed?output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deg = <span class="number">0</span>;</span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.style.transform = <span class="string">'rotate('</span> + deg++ + <span class="string">'deg)'</span>;</span><br><span class="line">    requestAnimationFrame(change);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面例子使用了 定时器<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a>，但是其并不是最佳的实现方法，下面让我们来解析其存在的问题:</p><ol><li>因为 <code>JavaScript</code> 是单线程，如果 <code>requestAnimationFrame</code> 被其他任务阻塞了，动画就会变慢(刷新率降低)</li><li>假定每次触发 <code>requestAnimationFrame</code> 时间一定，我们通过上例 <em>定义速度</em> 的方式来改变动画，会导致我们很难控制动画时间和动画的幅度，像前面这种匀速运动其实还好，如果做一些复杂的变速运动，按照我们的定义方式，我们本该设置的元素属性值将会类似于求积分，但是事实上时间又不连贯。</li></ol><h3 id="动画是“位移”关于“时间”的函数"><a href="#动画是“位移”关于“时间”的函数" class="headerlink" title="动画是“位移”关于“时间”的函数"></a>动画是“位移”关于“时间”的函数</h3><p>动画，是 <em>位移关于时间的函数</em> : \(s = f(t)\)<br>所以，我们<em>不该</em>采用增量的方式来执行动画，为了更精确地控制动画，更合适的方式是<em>将动画与时间联系起来</em></p><h4 id="动画与时间关联"><a href="#动画与时间关联" class="headerlink" title="动画与时间关联"></a>动画与时间关联</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="built_in">Date</span>.now() - startTime;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已执行时间: %fms'</span>, current);</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(change);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动画时间归一化表示"><a href="#动画时间归一化表示" class="headerlink" title="动画时间归一化表示"></a>动画时间归一化表示</h4><p>动画通常情况下有终止时间，如果是循环动画，我们也可以看做特殊的——当动画达到终止时间之后，重新开始动画。因此，我们可以将动画时间 <em>归一(Normalize)</em> 表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params">duration, isLoop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p =&gt; progress 动画进程数</span></span><br><span class="line">    <span class="keyword">var</span> p = (<span class="built_in">Date</span>.now() - startTime) / duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环归一化</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLoop) &#123;</span><br><span class="line">        startTime += duration;</span><br><span class="line">        p -= <span class="number">1.0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="number">1.0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已执行进度: %f'</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">      requestAnimationFrame(change);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画算子：-easing"><a href="#动画算子：-easing" class="headerlink" title="动画算子： easing"></a>动画算子： easing</h3><p>匀速运动、匀加速运动、匀减速运动、圆周运动唯一的区别仅仅在于位移方程：</p><ul><li>匀速运动：\(s_p = S \cdot P\)</li><li>匀加速运动：\(s_p = S \cdot P^2\)</li><li>匀减速运动：\(s_p = S \cdot P \cdot (2 - P)\)</li><li>圆周运动 x 轴：\(s_p = S \cdot cos(ωt)\)</li><li>圆周运动 y 轴：\(s_p = S \cdot sin(ωt)\)</li></ul><p>\(s_p\) 为当前位移量， \(S\) 为动画总位移量， \(P\) 为动画进程</p><p>我们把共同的部分 S 去掉，得到一个关于 p 的方程 \(e_p = E(p)\)，这个方程我们称为动画的算子(easing)，它决定了动画的性质。</p><ul><li>匀速算子：\(e_p = P\)</li><li>匀加速算子：\(e_p = P^2\)</li><li>匀减速算子：\(e_p = P \cdot (2 - P)\)</li><li>圆周算子 x 轴： \(e_p = cos(ωt)\)</li><li>圆周算子 y 轴： \(e_p = sin(ωt)\)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己曾尝试过写惯性动画，之前的方案是按照增量方式进行，但因为动画涉及元素多，计算量大，导致在一些机型会特别的卡（当然不排除代码问题），昨天在翻阅 <a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">iScroll</a> 源码的时候，才了解到了 <em>动画量子(easing)</em> 的存在，在阅读完这篇文章后，对 <em>动画量子</em> 又有了进一步的理解，之后将继续跟随这篇文章，对 js 动画做一个简易封装。</p><blockquote><p>原文链接 <a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 最新特性实现的三大黑科技</title>
    <link href="http://amu.fun/2017/06/19/knowledge/JavaScript%E6%9C%80%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E5%A4%A7%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://amu.fun/2017/06/19/knowledge/JavaScript最新特性实现的三大黑科技/</id>
    <published>2017-06-19T00:50:32.000Z</published>
    <updated>2019-02-25T08:21:42.311Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">《JavaScript 最新特性实现的三大黑科技》</a> 读后总结</p></blockquote><hr><h3 id="依次执行多项异步任务"><a href="#依次执行多项异步任务" class="headerlink" title="依次执行多项异步任务"></a>依次执行多项异步任务</h3><p><a class="jsbin-embed" href="//code.h5jun.com/dep/1/embed?console">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">taskReducer</span>(<span class="params">promise, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> promise;</span><br><span class="line">  <span class="keyword">return</span> action(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`task <span class="subst">$&#123;i&#125;</span> done`</span>);</span><br><span class="line">  <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[asyncTask, asyncTask, asyncTask].reduce(taskReducer, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>taskReducer</code> 的两个参数是 <code>promise</code> 和 <code>action</code>，<code>promise</code> 是代表当前任务的 <code>promise</code>，而 <code>action</code> 是下一个要执行的任务。我们可以 <code>await</code> 当前 <code>promise</code> 执行当前任务，然后将执行结果传给下一个 <code>action</code> 就可以了。</p><h3 id="generator-与-async-await-一同使用"><a href="#generator-与-async-await-一同使用" class="headerlink" title="generator 与 async/await 一同使用"></a>generator 与 async/await 一同使用</h3><p><a class="jsbin-embed" href="//code.h5jun.com/woge/2/embed?console">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">promise, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> promise;</span><br><span class="line">  <span class="keyword">return</span> action(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(++i), <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">continuous</span>(<span class="params">...functors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> functors.reduce(reducer, input);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">timing</span>(<span class="params">count = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> tick;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">continuous(...timing(<span class="number">10</span>))(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这部分没明白这么使用的优势在哪，<code>generator</code> 使用部分其实就是讲 <code>tick</code> 函数装入一个数组内，后使用 <code>continuous</code> 方法对其进行 <code>reduce</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将timing改为这样也可以运行，所以不明白使用 generator 的优势在哪</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">count = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    arr.push(tick);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Proxy-实现-PHP-中的常用“魔术方法”"><a href="#使用-Proxy-实现-PHP-中的常用“魔术方法”" class="headerlink" title="使用 Proxy 实现 PHP 中的常用“魔术方法”"></a>使用 Proxy 实现 PHP 中的常用“魔术方法”</h3><p>因为之前并没有对 <code>Proxy</code> 有过了解，所以另开了一篇文章对其做了下小总结 <a href="/2017/06/20/javascript/ES6-初识Proxy/">ES6 - 初识 Proxy</a><br>文章例子在对象构造的时候，分别“代理”对象实例的属性 get 和 set 方法，如果对象上已存在某个属性或方法，代理直接返回或操作该属性。否则，判断对象上是否有 <code>__get</code>、<code>__set</code> 或者 <code>__call</code> 方法，有的话，做相应的处理相当于是使用 <code>Proxy</code> “重载”对象的属性和方法读写。<br>这种加工并返回新类的方式，有函数式编程的感觉，我们也可以使用 <code>修饰器 Decorators</code> 来对其封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@magical</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    __call(key, ...args)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前写过相关文章 <a href="/2017/05/29/javascript/ES7修饰器/">ES7 修饰器</a></p><p>以上就是对 <a href="https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">《JavaScript 最新特性实现的三大黑科技》</a> 文章的读后感，谢谢原作者的分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; targ
      
    
    </summary>
    
      <category term="前端知识" scheme="http://amu.fun/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://amu.fun/tags/JavaScript/"/>
    
  </entry>
  
</feed>
