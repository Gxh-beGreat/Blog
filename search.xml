<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【译】DevTools 小技巧 day 5 —— 诡异的 console.log</title>
      <link href="/2018/12/11/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%205%20%E2%80%94%E2%80%94%20%E8%AF%A1%E5%BC%82%E7%9A%84%20console.log/"/>
      <url>/2018/12/11/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%205%20%E2%80%94%E2%80%94%20%E8%AF%A1%E5%BC%82%E7%9A%84%20console.log/</url>
      <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://medium.com/@tomsu/devtools-tips-day-5-the-curious-case-of-console-log-36bc7e27a97f" target="_blank" rel="noopener">DevTools tips — day 5: the curious case of console.log</a> by <a href="https://twitter.com/sulco" target="_blank" rel="noopener">Tomek Sułkowski</a><br>译者在翻译第六篇时，发现 <a href="https://juejin.im/user/585a2f52128fe10069ba1b95" target="_blank" rel="noopener">dendoink</a> 已在进行 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">【译】你不知道的 Chrome 调试工具技巧</a>的翻译工作，译者决定停止该系列的后续更新。</p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。</p><h2 id="16-记录的对象并非预期值"><a href="#16-记录的对象并非预期值" class="headerlink" title="16. 记录的对象并非预期值"></a>16. 记录的对象并非预期值</h2><p><code>console.log</code> 对于 <code>对象</code> 的输出方式，多少都让我们在调试的时候困惑过或是踩到坑：</p><blockquote><p>通过控制台输出的对象值，将通过引用的方式进行存储的，开发者展开查看到的都将会是对象的最新属性值</p></blockquote><p>这意味着如果你是记录一个对象，修改其属性值并再次 log，查看控制台，你将看到第一个日志（修改之前）…与第二个日志具有相同的值！</p><p>下面的动图会展示这种情况：<br><img src="/images/DevTools小技巧/5-1.gif" alt></p><p>现在想象一下，当你试图对比一个对象属性修改前后的值是否符合要求的时候，这个问题就很伤脑筋了~ 🤯</p><p>那么这种情况要怎么处理呢？好吧，你可能需要记录一个对象的副本（一个新的引用）或……在 <code>serious debugging</code>（译者理解为 Sources 面板中的断点代码调试） 中使用 断点 和 Sources 面板代替！</p>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
            <tag> 文章翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】DevTools 小技巧 day 4 —— Elements 面板</title>
      <link href="/2018/12/10/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%204%20%E2%80%94%E2%80%94%20Elements%20%E9%9D%A2%E6%9D%BF/"/>
      <url>/2018/12/10/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%204%20%E2%80%94%E2%80%94%20Elements%20%E9%9D%A2%E6%9D%BF/</url>
      <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://medium.com/@tomsu/devtools-tips-day-4-console-methods-47c854782cef" target="_blank" rel="noopener">DevTools tips — day 4: the Elements panel</a> by <a href="https://twitter.com/sulco" target="_blank" rel="noopener">Tomek Sułkowski</a><br>译者在翻译第六篇时，发现 <a href="https://juejin.im/user/585a2f52128fe10069ba1b95" target="_blank" rel="noopener">dendoink</a> 已在进行 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">【译】你不知道的 Chrome 调试工具技巧</a>的翻译工作，译者决定停止该系列的后续更新。</p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。今天我们将讲一些关于 Elements 面板的使用小技巧</p><h2 id="12-使用-”h“-隐藏元素"><a href="#12-使用-”h“-隐藏元素" class="headerlink" title="12. 使用 ”h“ 隐藏元素"></a>12. 使用 ”h“ 隐藏元素</h2><p>只需按 <code>h</code> 即可隐藏在 Elements 面板中选中的元素。再次按 <code>h</code> 使其重新出现。<br>这对于网页截图，且需要隐藏部分敏感性数据时很有效</p><p><img src="/images/DevTools小技巧/4-1.gif" alt></p><h2 id="13-拖放元素"><a href="#13-拖放元素" class="headerlink" title="13. 拖放元素"></a>13. 拖放元素</h2><p>如果想要检查 html 的节点在 DOM 树的其他位置会是怎样的情况，只需使用鼠标将其拖放到对应位置，就像你在电脑上拖放文件一样:-)</p><p><img src="/images/DevTools小技巧/4-2.gif" alt></p><h2 id="14-…或使用键盘控制！"><a href="#14-…或使用键盘控制！" class="headerlink" title="14. …或使用键盘控制！"></a>14. …或使用键盘控制！</h2><p>如果你想在 DOM 结构上向下或向下移动当前选中的元素，而不是拖放，你也可以使用 <code>[ctrl] + [⬆]</code>/ <code>[ctrl] + [⬇]</code>（Mac 下使用<code>[⌘] + [⬆]</code> / <code>[⌘] + [⬇]</code>）。</p><p><img src="/images/DevTools小技巧/4-3.gif" alt></p><h2 id="15-它等同于一个编辑器"><a href="#15-它等同于一个编辑器" class="headerlink" title="15. 它等同于一个编辑器"></a>15. 它等同于一个编辑器</h2><p>我们可以在 Elements 面板里进行拖放，编辑，复制（是的，也可以使用 <code>[ctrl] + [v]</code> 进行粘贴），一旦我们弄乱了 html 结构，不需要担心，在任何文本/图形编辑器中的标准是什么：</p><ul><li>使用 <code>[ctrl] + [z]</code>（Mac 上的 <code>[⌘] + [z]</code>）撤消上一步操作</li><li>使用 <code>[ctrl] + [shift] + [z]</code> 重做撤销的操作</li></ul><p><img src="/images/DevTools小技巧/4-4.gif" alt></p>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
            <tag> 文章翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】DevTools 小技巧 day 3 —— console 方法</title>
      <link href="/2018/12/09/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%203%20%E2%80%94%E2%80%94%20console%20%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/09/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%203%20%E2%80%94%E2%80%94%20console%20%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>原文地址：<a href="https://medium.com/@tomsu/devtools-tips-day-3-console-methods-783791e91990" target="_blank" rel="noopener">DevTools tips — day 3: console methods</a> by <a href="https://twitter.com/sulco" target="_blank" rel="noopener">Tomek Sułkowski</a><br>译者在翻译第六篇时，发现 <a href="https://juejin.im/user/585a2f52128fe10069ba1b95" target="_blank" rel="noopener">dendoink</a> 已在进行 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">【译】你不知道的 Chrome 调试工具技巧</a>的翻译工作，译者决定停止该系列的后续更新。</p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。我们在<a href="2018/12/08/apps/DevTools小技巧/day%202%20——%20复制&amp;保存/">上一篇</a>中已经介绍到了第 8 种技巧，那么今天我们将从第 9 开始。</p><h2 id="9-console-assert"><a href="#9-console-assert" class="headerlink" title="9. console.assert"></a>9. console.assert</h2><p><img src="/images/DevTools小技巧/3-1.png" alt="出自: https://developer.mozilla.org/en-US/docs/Web/API/console/assert"></p><p><code>console.assert</code> 方法第一个参数（断言）为 <code>false</code> 时，则将一个错误消息写入控制台，如果断言是 true，没有任何反应。<br>这个方法对于在特定条件下记录消息时很有用，你可以在不书写 <code>if</code> 语句的情况下执行此操作，而且你还能从这里得到对应的堆栈跟踪 😁</p><p><img src="/images/DevTools小技巧/3-2.gif" alt></p><h2 id="10-console-table"><a href="#10-console-table" class="headerlink" title="10.console.table"></a>10.console.table</h2><p>这是一个鲜为人知的方法。<br>如果你有一个数组（或类似数组的对象，或者只是一个对象），你可以使用 <code>console.table</code> 方法在控制台中以一个漂亮的表的形式打印它。<br>它不仅会基于数据所包含的属性来计算表列名称，而且列也可以调整大小甚至可排序！😳<br>如果列太多，你还可以使用第二个参数，传入需要显示的列名数组。</p><p><img src="/images/DevTools小技巧/3-3.gif" alt></p><blockquote><p>哦！如果你还同时涉猎 nodejs 后端，那么恭喜你！10.0 版本之后，你也可以使用 <code>console.table</code> 啦!</p></blockquote><h2 id="11-console-dir"><a href="#11-console-dir" class="headerlink" title="11. console.dir"></a>11. console.dir</h2><p>最常使用的 <code>console.log</code> 方法，在大多数情况下，都以最合适的格式化数据输出给开发人员，但有时它可能不是你想要看到的 —— 典型的例子是打印出一个 DOM 节点。<br><code>console.log</code> 将呈现此交互式元素，它看起来就像刚从 <code>Elements</code> 面板中剪切出来一样。<br>如果要检查它引用的实际 JavaScript 对象，该怎么办，查看它的属性等呢？<br>在这种情况下，如果您需要更多信息描述数据，请改用 <code>console.dir</code>。</p><p><img src="/images/DevTools小技巧/3-4.gif" alt></p><p>这就是今天所有的内容啦！😉</p>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
            <tag> 文章翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】DevTools 小技巧 day 2 —— 复制 &amp; 保存</title>
      <link href="/2018/12/08/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%202%20%E2%80%94%E2%80%94%20%E5%A4%8D%E5%88%B6&amp;%E4%BF%9D%E5%AD%98/"/>
      <url>/2018/12/08/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%202%20%E2%80%94%E2%80%94%20%E5%A4%8D%E5%88%B6&amp;%E4%BF%9D%E5%AD%98/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>原文地址：<a href="https://medium.com/@tomsu/devtools-tips-day-2-copying-saving-6aa9bbdadbe21" target="_blank" rel="noopener">DevTools tips — day 2: copying &amp; saving</a> by <a href="https://twitter.com/sulco" target="_blank" rel="noopener">Tomek Sułkowski</a><br>译者在翻译第六篇时，发现 <a href="https://juejin.im/user/585a2f52128fe10069ba1b95" target="_blank" rel="noopener">dendoink</a> 已在进行 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">【译】你不知道的 Chrome 调试工具技巧</a>的翻译工作，译者决定停止该系列的后续更新。</p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧。我们在<a href="2018/12/06/apps/DevTools小技巧/day%201%20——%20控制台%20$/">上一篇</a>中介绍了 4 种技巧，那么今天我们让这里开始吧…</p><h2 id="5-copy-…"><a href="#5-copy-…" class="headerlink" title="5. copy(…)"></a>5. copy(…)</h2><p>我们可以使用控制台种提供全局方法 <code>copy</code> 将控制台内的所有可用内容复制到剪贴板中，这也包括我们在<a href="2018/12/06/apps/DevTools小技巧/day%201%20——%20控制台%20$/">上一篇</a>中介绍到的引用变量，比如: <code>copy(_$)</code> 或 <code>copy($0)</code><br><img src="/images/DevTools小技巧/2-1.gif" alt></p><h2 id="6-生成全局变量"><a href="#6-生成全局变量" class="headerlink" title="6. 生成全局变量"></a>6. 生成全局变量</h2><p>如果你有一些数据（比如你从你的程序中计算出来的一个数组）打印在控制台，并且你想要使用这部分数据做一些其他方面的工作，例如你想把这部分数据使用 <code>copy</code> 函数复制出来，你可以直接从控制台轻松将其作为全局变量使用。</p><p>你只需要右键打印出来的数据，并且选择 <code>Store as global variable</code> 选项。</p><p>首次使用这种方式存储，数据将会被复制给全局变量 <code>temp1</code>，其次是 <code>temp2</code>，以此类推，因此你可以多次使用存储多个值，且不需要担心会有变量被覆盖的风险。</p><p><img src="/images/DevTools小技巧/2-2.gif" alt></p><h2 id="7-保存错误堆栈跟踪信息"><a href="#7-保存错误堆栈跟踪信息" class="headerlink" title="7. 保存错误堆栈跟踪信息"></a>7. 保存错误堆栈跟踪信息</h2><p>堆栈跟踪信息对于你跟你的同事都很有用（例如：与其他前端开发人员或 QA 工程师一起工作）。<br>你可以将堆栈跟踪保存到文件中，从而抛弃截图的形式。<br><img src="/images/DevTools小技巧/2-3.gif" alt></p><h2 id="8-复制-HTML-文本-（快捷方式）"><a href="#8-复制-HTML-文本-（快捷方式）" class="headerlink" title="8. 复制 HTML 文本 （快捷方式）"></a>8. 复制 HTML 文本 （快捷方式）</h2><p>你可能知道可以右键单击或单击 html 元素旁边的省略号（•••）将其复制到操作系统剪贴板。</p><p>但你也可以使用 <code>[ctrl] + [c]</code> 快捷键（Mac 上的 <code>[⌘] + [c]</code> ）来实现同样的目的！🚀</p><p><img src="/images/DevTools小技巧/2-4.gif" alt></p>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
            <tag> 文章翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】DevTools 小技巧 day 1 —— 控制台 $</title>
      <link href="/2018/12/06/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%201%20%E2%80%94%E2%80%94%20%E6%8E%A7%E5%88%B6%E5%8F%B0%20$/"/>
      <url>/2018/12/06/apps/DevTools%E5%B0%8F%E6%8A%80%E5%B7%A7/day%201%20%E2%80%94%E2%80%94%20%E6%8E%A7%E5%88%B6%E5%8F%B0%20$/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>原文地址：<a href="https://medium.com/@tomsu/devtools-tips-day-1-the-console-dollars-3aa0d93e923c" target="_blank" rel="noopener">DevTools tips — day 1: the console dollars</a> by <a href="https://twitter.com/sulco" target="_blank" rel="noopener">Tomek Sułkowski</a><br>译者在翻译第六篇时，发现 <a href="https://juejin.im/user/585a2f52128fe10069ba1b95" target="_blank" rel="noopener">dendoink</a> 已在进行 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">【译】你不知道的 Chrome 调试工具技巧</a>的翻译工作，译者决定停止该系列的后续更新。</p></blockquote><hr><p>在圣诞节 🎄 前的 24 天里，我将通过短篇幅的形式为大家分享更高效有趣的 <code>DevTools</code> 使用技巧，现在就让我们开始吧！</p><h2 id="1-0"><a href="#1-0" class="headerlink" title="1. $0"></a>1. <code>$0</code></h2><p><code>$0</code> 是对当前 Elements 面板中选定的 html 节点的引用<br><code>$1</code> 则是对上一次选定的节点的引用，<code>$2</code> 是对上上一次选定的引用，以此类推，最多可支持到 <code>$4</code><br>你可以使用这些引用变量来进行对用的操作（例如：<code>$1.appendChild($0)</code>）。<br><img src="/images/DevTools小技巧/1-1.gif" alt></p><h2 id="2-and"><a href="#2-and" class="headerlink" title="2. $ and $$"></a>2. <code>$ and $$</code></h2><p>控制台里的 <code>$</code> 是冗长方法 <code>document.querySelector</code> 的别名。<br>使用的前提条件是你的应用中没有声明 <code>$</code> 变量（例如： JQuery）。</p><p><code>$$</code>更是个省时利器了 🚀，它不仅会执行 <code>document.QuerySelectorAll</code> 方法，而且会将节点以数组的形式返回，而非 <code>NodeList</code> 类型。</p><p>通常情况下：<code>Array.from(document.querySelectorAll(&#39;div&#39;)) === $$(&#39;div&#39;)</code><br>超便捷有木有！！🚀<br><img src="/images/DevTools小技巧/1-2.gif" alt></p><h2 id="3"><a href="#3" class="headerlink" title="3. $_"></a>3. <code>$_</code></h2><p><code>$_</code> 是上一次计算的表达式结果的引用。<br><img src="/images/DevTools小技巧/1-3.png" alt></p><h2 id="4-i"><a href="#4-i" class="headerlink" title="4. $i"></a>4. <code>$i</code></h2><p>通过 Chrome 的 <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie" target="_blank" rel="noopener">Console Importer</a> 扩展程序，我们可以快捷的在控制台导入并使用 <code>npm</code>。<br>只需执行 <code>$i(&#39;lodash&#39;) or $i(&#39;moment&#39;)</code>，几秒之后 🕙，我们便可以获取到 <code>lodash/moment</code> 啦！</p><p><img src="/images/DevTools小技巧/1-4.gif" alt></p><p>以上就是今天到全部内容啦。Short and sweet.🍬</p>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
            <tag> 文章翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web性能信息采集 — 高精度时间</title>
      <link href="/2018/11/22/knowledge/performance/Web%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86%20%E2%80%94%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%97%B6%E9%97%B4/"/>
      <url>/2018/11/22/knowledge/performance/Web%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86%20%E2%80%94%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://github.com/berwin/Blog/issues/25" target="_blank" rel="noopener">2018 你应该知道的 Web 性能信息采集指南</a> - 如何获得高精度的时间？</p></blockquote><hr><h3 id="如何获得高精度的时间（摘录）"><a href="#如何获得高精度的时间（摘录）" class="headerlink" title="如何获得高精度的时间（摘录）"></a>如何获得高精度的时间（摘录）</h3><p>ECMA-262 规范中定义了 <code>Date</code> 对象来表示自 1970 年 1 月 1 日以来的毫秒数。它足以满足大部分需求，但缺点是时间会受到时钟偏差与系统时钟调整的影响。时间的值不总是单调递增，后续值有可能会减少或者保持不变。</p><p>例如，下面这段代码计算出来的“<code>duration</code>”有可能被记录为正数、负数或零。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark_start = <span class="built_in">Date</span>.now();</span><br><span class="line">doTask(); <span class="comment">// Some task</span></span><br><span class="line"><span class="keyword">const</span> duration = <span class="built_in">Date</span>.now() - mark_start;</span><br></pre></td></tr></table></figure><p>上面这段代码获取的持续时间“duration”并不精准，它会受到时钟偏差与系统时钟调整的影响，所以最终得到的“duration”可能为正数、负数或零，我们根本不知道它记录的时间究竟是不是正确的时间。</p><p>高精度时间（High Resolution Time，简称<code>hr-time</code>）规范定义了<code>Performance</code>对象，通过<code>Performance</code>对象我们可以获得高精度的时间。</p><p><code>Performance</code>对象包含方法<code>now</code>和属性<code>timeOrigin</code>：</p><ul><li>方法<code>now</code>被执行后会返回从 <code>timeOrigin</code> 到现在的高精度时间。<blockquote><p><em>当前时间 - performance.timeOrigin</em></p></blockquote></li><li><p>属性<code>timeOrigin</code>返回<a href="https://html.spec.whatwg.org/multipage/browsers.html#creating-a-new-browsing-context" target="_blank" rel="noopener">页面浏览上下文第一次被创建</a>的时间。如果全局对象为<code>WorkerGlobalScope</code>，那么<code>timeOrigin</code>为 worker 被创建的时间。</p><blockquote><p>timeOrigin 的时间值不受时钟偏差与系统时钟调整的影响。</p></blockquote><p>例如，当<code>timeOrigin</code>的值被确定之后，无论将系统时间设置到什么时间，下面代码始终返回<code>timeOrigin</code>最初被赋予的时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(performance.timeOrigin).toLocaleString();</span><br><span class="line"><span class="comment">// 2018/8/6 上午11:41:58</span></span><br></pre></td></tr></table></figure></li></ul><p>如果两个时间值拥有相同的时间起源（<a href="https://w3c.github.io/hr-time/#dfn-time-origin" target="_blank" rel="noopener">Time Origin</a>），那么使用 <code>performance.now</code> 方法返回的任意两个按时间顺序记录的时间值之间的差值永远不可能是负数。</p><p>例如，下面这段代码计算出来的“<code>duration</code>”永远不可能为负数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark_start = performance.now();</span><br><span class="line">doTask(); <span class="comment">// Some task</span></span><br><span class="line"><span class="keyword">const</span> duration = performance.now() - mark_start;</span><br></pre></td></tr></table></figure><p>通过<code>performance.timeOrigin</code> + <code>performance.now</code> 可以得到精准的当前时间。该时间不受时钟偏差与系统时钟调整的影响。</p><blockquote><p>不受时钟偏差与系统时钟调整的影响指的是当<code>timeOrigin</code>的值被确定之后修改了系统时间，这时候<code>timeOrigin</code>不会受到影响。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeStamp = performance.timeOrigin + performance.now();</span><br><span class="line"><span class="built_in">console</span>.log(timeStamp); <span class="comment">// 1533539552977.5718</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp).toLocaleString();</span><br><span class="line"><span class="comment">// "2018/8/6 下午3:10:42"</span></span><br></pre></td></tr></table></figure><h3 id="场景使用"><a href="#场景使用" class="headerlink" title="场景使用"></a>场景使用</h3><p>高精度时间 <code>performance.now</code>，想到的场景使用有以下几个：</p><ol><li>可以用于微秒级动画的效果的使用上，具体使用方式可参考 <a href="/2017/06/22/knowledge/实现JavaScript动画序列播放/#performance-now-获取当前时间">实现 JavaScript 动画序列播放</a></li><li><code>Web端时钟</code>，获取服务器准确时间作为基准值，根据 <code>performance.now</code> 计算 <code>duration</code>，虽然有网络请求时间误差，但是可以避免受到系统时间调整带来的影响</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serverTime = (<span class="keyword">await</span> getServerTime()) - performance.now();</span><br><span class="line"><span class="keyword">let</span> nowTime;</span><br><span class="line">setInterval(</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">getRealTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nowTime = serverTime + performance.now();</span><br><span class="line">    <span class="keyword">return</span> getRealTime;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>活动/商品购买倒计时</code>，同第二点类似，均已服务器时间为基准值，计算距离结束时间的 <code>duration</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; serverStartTime, serverEndTime &#125; = <span class="keyword">await</span> getServerTime();</span><br><span class="line"><span class="keyword">const</span> nowTime = performance.now();</span><br><span class="line"><span class="keyword">const</span> serverDurationForNowToEnd = serverEndTime - serverStartTime;</span><br><span class="line"><span class="keyword">let</span> realDurationForNowToEnd = <span class="number">0</span>;</span><br><span class="line">setInterval(</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">getRealDuration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    realDurationForNowToEnd =</span><br><span class="line">      serverDurationForNowToEnd - performance.now() - nowTime;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端防止页面调试方法</title>
      <link href="/2018/08/16/knowledge/%E5%89%8D%E7%AB%AF%E9%98%B2%E6%AD%A2%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/16/knowledge/%E5%89%8D%E7%AB%AF%E9%98%B2%E6%AD%A2%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>使用 chrome 模拟器打开，会一直进入 debugger 模式</p></blockquote><hr><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> protection = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="string">''</span> + times / times)[<span class="string">'length'</span>] !== <span class="number">1</span> || times % <span class="number">20</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span><br><span class="line">    &#125;</span><br><span class="line">    loop(++times);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loop(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">protection();</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React - 组件类型</title>
      <link href="/2017/08/30/knowledge/react/React%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/08/30/knowledge/react/React%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="http://mp.weixin.qq.com/s/U4REXWqmVa-XgyR1_fUf7A" target="_blank" rel="noopener">前端早读课 - 《【第 1042 期】React 之组件类型》</a> 读后总结</p></blockquote><hr><p>本文介绍了 <code>React</code> 当中有关组件的一系列概念:</p><ul><li>元素与组件 <code>Element</code> &amp; <code>Component</code></li><li>函数定义与类定义组件 <code>Functional</code> &amp; <code>Class</code></li><li>展示与容器组件 <code>Presentational</code> &amp; <code>Container</code></li><li>有状态与无状态组件 <code>Stateful</code> &amp; <code>Stateless</code></li><li>受控与非受控组件 <code>Controlled</code> &amp; <code>Uncontrolled</code></li><li>组合与继承 <code>Composition</code> &amp; <code>Inheritance</code></li></ul><h2 id="元素与组件-Element-amp-Component"><a href="#元素与组件-Element-amp-Component" class="headerlink" title="元素与组件 Element &amp; Component"></a>元素与组件 Element &amp; Component</h2><p>使用 <code>html element</code> 作为标签项的 <code>React DOM</code>，被称为 _元素_，元素是构建 React 应用的最小单位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line"><span class="comment">// 用JSX描述就相当于是调用React的方法创建了一个对象</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'Hello, world'</span>);</span><br></pre></td></tr></table></figure><p>React 官方对组件的定义，是指在 UI 界面中，可以被独立划分的、可复用的、独立的模块。其实就类似于 JS 当中对 <code>function</code> 函数的定义，它一般会接收一个名为 <code>props</code> 的输入，然后返回相应的 <code>React</code> 元素，再交给 <code>ReactDOM</code>，最后渲染到屏幕上。</p><h2 id="函数定义与类定义组件-Functional-amp-Class"><a href="#函数定义与类定义组件-Functional-amp-Class" class="headerlink" title="函数定义与类定义组件 Functional &amp; Class"></a>函数定义与类定义组件 Functional &amp; Class</h2><p>函数定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = <span class="function"><span class="params">props</span> =&gt;</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br></pre></td></tr></table></figure><p>类定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示与容器组件-Presentational-amp-Container"><a href="#展示与容器组件-Presentational-amp-Container" class="headerlink" title="展示与容器组件 Presentational &amp; Container"></a>展示与容器组件 Presentational &amp; Container</h2><p><em>展示组件：</em></p><ul><li>主要负责组件内容如何展示</li><li>从 <code>props</code> 接收父组件传递来的数据</li><li>大多数情况可以通过函数定义组件声明</li></ul><p><em>容器组件：</em></p><ul><li>主要关注组件数据如何交互</li><li>拥有自身的 <code>state</code>，从服务器获取数据，或与 <code>redux</code> 等其他数据处理模块协作</li><li>需要通过类定义组件声明，并包含生命周期函数和其他附加方法</li></ul><p>那么这样写具体有什么好处呢？</p><ul><li>解耦了界面和数据的逻辑</li><li>更好的可复用性，比如同一个回复列表展示组件可以套用不同数据源的容器组件</li><li>利于团队协作，一个人负责界面结构，一个人负责数据交互</li></ul><h2 id="有状态与无状态组件-Stateful-amp-Stateless"><a href="#有状态与无状态组件-Stateful-amp-Stateless" class="headerlink" title="有状态与无状态组件 Stateful &amp; Stateless"></a>有状态与无状态组件 Stateful &amp; Stateless</h2><p>有状态组件是指这个组件能够获取储存改变应用或组件本身的状态数据，在 <code>React</code> 当中也就是 <code>state</code>，一些比较明显的特征是我们可以在这样的组件当中看到对 <code>this.state</code> 的初始化，或 this.setState 方法的调用等等。而无状态组件一般只能看到对 <code>this.props</code> 的调用，大部分无状态组件都是函数定义组件</p><h2 id="受控与非受控组件-Controlled-amp-Uncontrolled"><a href="#受控与非受控组件-Controlled-amp-Uncontrolled" class="headerlink" title="受控与非受控组件 Controlled &amp; Uncontrolled"></a>受控与非受控组件 Controlled &amp; Uncontrolled</h2><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>一般涉及到表单元素时我们才会使用这种分类方法。受控组件的值由 <code>props</code> 或 <code>state</code> 传入，用户在元素上交互或输入内容会引起应用 <code>state</code> 的改变。在 <code>state</code> 改变之后重新渲染组件，我们才能在页面中看到元素中值的变化，假如组件没有绑定事件处理函数改变 <code>state</code>，用户的输入是不会起到任何效果的，这也就是 _受控_ 的含义所在。</p><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>类似于传统的 <code>DOM</code> 表单控件，用户输入不会直接引起应用 <code>state</code> 的变化，我们也不会直接为非受控组件传入值。想要获取非受控组件，我们需要使用一个特殊的 <code>ref</code> 属性，同样也可以使用 <code>defaultValue</code> 属性来为其指定一次性的默认值。</p><h2 id="组合与继承-Composition-amp-Inheritance"><a href="#组合与继承-Composition-amp-Inheritance" class="headerlink" title="组合与继承 Composition &amp; Inheritance"></a>组合与继承 Composition &amp; Inheritance</h2><p>即 <code>hoc</code>、<code>类继承</code> 的方式</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript语言精粹 - 函数篇(二)</title>
      <link href="/2017/07/29/books/theGoodParts/3/"/>
      <url>/2017/07/29/books/theGoodParts/3/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 函数篇(二)，高级篇</p></blockquote><hr><p>这篇文章我们将学习类型功能的扩展、递归的使用、闭包、级联、柯里化等函数的高级特性及用法</p><h2 id="扩展类型的功能-Augmenting-Types"><a href="#扩展类型的功能-Augmenting-Types" class="headerlink" title="扩展类型的功能(Augmenting Types)"></a>扩展类型的功能(Augmenting Types)</h2><p><code>JavaScript</code> 允许给 <em>基本类型</em> 扩充功能，在对象篇，我们了解到可以通过修改 <code>Object.prototype</code>, 使得所有对象都能继承到该改变。这样的方式对函数、数组、字符串、数字、正则和布尔值同样适用。<br>举例来说,我们可以通过 <code>Function.prototype</code> 增加方法来使得该方法对所有函数可用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototype[method] = func;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过给 <code>Function.prototype</code> 增加 <code>method</code> 方法，我们下次给对象增加方法的时候就不必键入 <code>prototype</code> 这几个字符，省掉了一些麻烦</p><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归(Recursion)"></a>递归(Recursion)</h2><p>递归函数就是会直接或间接地调用自身的一种函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔</span></span><br><span class="line"><span class="keyword">const</span> hanoi = <span class="function"><span class="keyword">function</span>(<span class="params">disc, src, aux, dst</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (disc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    hanoi(disc - <span class="number">1</span>, src, dst, aux);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Move disc <span class="subst">$&#123;disc&#125;</span> from <span class="subst">$&#123;src&#125;</span> to <span class="subst">$&#123;dst&#125;</span>`</span>);</span><br><span class="line">    hanoi(disc - <span class="number">1</span>, aux, src, dst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些语言提供了<code>尾递归</code>优化，这意味着如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，可显著提高速度，但 <code>JavaScript</code> 当前没有提供尾递归优化，深度递归的函数可能会因为堆栈溢出而运行失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个带尾递归的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">i, a = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> factorial(i - <span class="number">1</span>, a * i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">4</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><p>因为作用域的关系，函数可以访问它被创建时所处的上下文环境，上下文环境中的参数被函数使用时，该参数不会被销毁，并被函数直接访问，这种模式被称为 <code>闭包</code>，我们可以使用 <code>闭包</code> 的方式去封装一些私有属性、方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment(inc) &#123;</span><br><span class="line">      value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue() &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="级联-Cascade"><a href="#级联-Cascade" class="headerlink" title="级联(Cascade)"></a>级联(Cascade)</h2><p>如果我们让 _方法_ 返回返回 <code>this</code>，则可以实现 <code>级联</code>，即 <code>链式调用</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  increment(inc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  reduce(inc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value -= <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject</span><br><span class="line">  .increment(<span class="number">3</span>)</span><br><span class="line">  .reduce(<span class="number">2</span>)</span><br><span class="line">  .increment(<span class="number">1</span>)</span><br><span class="line">  .getValue(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h2><p><code>柯里化</code> 是函数式编程常用的方式，它允许我们把函数与传递给它的参数相结合，产生出一个新的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = add.curry(<span class="number">1</span>);</span><br><span class="line">add1(<span class="number">6</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 没有 <code>curry</code> 方法，但我们可以给 <code>Function.prototype</code> 扩充此功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.method(<span class="string">'curry'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的this指向函数自身</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.apply(<span class="literal">null</span>, args.concat(args2));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="记忆-Memoization"><a href="#记忆-Memoization" class="headerlink" title="记忆(Memoization)"></a>记忆(Memoization)</h2>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript语言精粹 - 函数篇(一)</title>
      <link href="/2017/07/28/books/theGoodParts/2/"/>
      <url>/2017/07/28/books/theGoodParts/2/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 函数篇(一),基础篇</p></blockquote><hr><h2 id="函数对象-Function-Objects"><a href="#函数对象-Function-Objects" class="headerlink" title="函数对象(Function Objects)"></a>函数对象(Function Objects)</h2><p><code>JavaScript</code> 中的函数即是对象,对象字面量产生的对象连接到 <code>Object.prototype</code>,函数对象连接到 <code>Function.prototype</code> (该原型对象本身连接到 <code>Object.prototype</code>)，每个函数在创建时会附加两个隐藏属性： 函数的 <em>上下文</em> 和 <em>实现函数行为的代码</em>(调用函数时即调用该 <code>调用</code> 属性)<br>每个函数对象在创建时也随配有一个 <code>prototype</code> 属性，它的值是一个拥有 <code>constructor</code> 属性且值为该函数的对象<br>函数的与众不同之处在于它们可以被调用</p><h2 id="调用-Invocation"><a href="#调用-Invocation" class="headerlink" title="调用(Invocation)"></a>调用(Invocation)</h2><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数: <code>this</code> 和 <code>arguments</code>。参数 <code>this</code> 在面向对象编程中非常重要，它的值取决于调用的模式。在 <code>JavaScript</code> 中一共有 _4_ 中调用模式:<code>方法调用</code>、<code>函数调用</code>、<code>构造器调用</code> 和 <code>apply 调用</code>。这些模式在如何初始化关键参数 <code>this</code> 上存在差异</p><h3 id="方法调用模式-The-Method-Invocation-Pattern"><a href="#方法调用模式-The-Method-Invocation-Pattern" class="headerlink" title="方法调用模式(The Method Invocation Pattern)"></a>方法调用模式(The Method Invocation Pattern)</h3><p>当一个函数被保存为对象的一个属性时，我们称它为一个 <code>方法</code>。当一个方法被调用时，<code>this</code> 被绑定到该对象，如果调用表达式包含一个 <em>提取属性</em> 的动作(即包含一个 <code>.</code> 点表达式或 <code>[subscript]</code> 下标表达式),那么它就是被当做一个方法来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params">inc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += typeOf inc === <span class="string">'number'</span> ? inc : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment()</span><br><span class="line">myObject.value <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">2</span>)</span><br><span class="line">myObject.value <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>方法可以使用 <code>this</code> 访问自己所属的对象，<code>this</code> 到对象的绑定发生在 _调用_ 的时候，这个”超级”延迟绑定(<code>vary late binding</code>) 使得函数可以对 <code>this</code> 高度复用。通过 <code>this</code> 可取得它们所属对象的上下文的方法称为公共方法(<code>public method</code>)。</p><h3 id="函数调用模式-The-Function-Invocation-Pattern"><a href="#函数调用模式-The-Function-Invocation-Pattern" class="headerlink" title="函数调用模式(The Function Invocation Pattern)"></a>函数调用模式(The Function Invocation Pattern)</h3><p>当一个函数并非一个对象的属性时，那么它将被当做一个函数来调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 函数将返回两个传入参数的相加值</span></span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>通过该模式调用函数时，<code>this</code> 被绑定到全局对象。<em>这是语言设计上的一个错误</em>。倘若语言设计正确，那么当内部函数被调用时，<code>this</code> 应该仍然绑定到外部函数的 <code>this</code> 变量。这个设计错误的后果就是方法不能利用内部函数来帮助它工作，因为内部函数的 <code>this</code> 被绑定了错误的值，所以不能共享该方法对对象的访问权。幸运的是，有一个很容易的解决方案：如果该方法定义一个变量并给它赋值为 <code>this</code>,那么内部函数就可以通过那个变量访问到 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myObject.double = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.value = add(that.value, that.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  helper();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.double();</span><br><span class="line">myObject.value; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="构造器调用模式-The-Constructor-Invocation-Pattern"><a href="#构造器调用模式-The-Constructor-Invocation-Pattern" class="headerlink" title="构造器调用模式(The Constructor Invocation Pattern)"></a>构造器调用模式(The Constructor Invocation Pattern)</h3><p>如果在一个函数前面带上 <code>new</code> 来调用，那么背地里将会创建一个连接到该函数的 <code>prototype</code> 成员的新对象，同时 <code>this</code> 会被绑定到那个新对象上<br><code>new</code> 前缀也会改变 <code>return</code> 语句的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数对象在创建时也随配有一个 `prototype` 属性，它的值是一个拥有 `constructor` 属性且值为该函数的对象</span></span><br><span class="line"><span class="keyword">const</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.status = string;</span><br><span class="line">&#125;;</span><br><span class="line">Quo.prototype.get_status = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 Quo 实例</span></span><br><span class="line"><span class="keyword">const</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">'confused'</span>);</span><br><span class="line">myQuo.get_status(); <span class="comment">// 'confused'</span></span><br></pre></td></tr></table></figure><p>该调用模式调用的函数被称为 <code>构造器函数</code>,一般约定以 <em>首字母大写</em> 的命名方式命名，但是这种形式的构造器函数并不推荐，我们将在后续的学习中学习到更优的替代方式</p><h3 id="Apply-调用模式-The-Apply-Invocation-Pattern"><a href="#Apply-调用模式-The-Apply-Invocation-Pattern" class="headerlink" title="Apply 调用模式(The Apply Invocation Pattern)"></a>Apply 调用模式(The Apply Invocation Pattern)</h3><p><code>JavaScript</code> 是一门函数式的面向对象编程语言，即函数可以拥有自己的方法。<br><code>apply</code> 方法让我们构建一个参数数组传递给调用函数，它也允许我们选择 <code>this</code> 的值。<code>apply</code> 方法接受两个参数，第一个是要绑定给 <code>this</code> 的值，第二个是一个<code>参数数组</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = add.apply(<span class="literal">null</span>, array); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusObj = &#123;</span><br><span class="line">  status: <span class="string">'A-OK'</span></span><br><span class="line">&#125;;</span><br><span class="line">Quo.prototype.get_status.apply(statusObj); <span class="comment">// 'A-OK'</span></span><br></pre></td></tr></table></figure><h2 id="参数-Arguments"><a href="#参数-Arguments" class="headerlink" title="参数(Arguments)"></a>参数(Arguments)</h2><p>当函数被调用时，会得到一个“免费”配送的参数 —— <code>arguments</code>,它是一个类数组，用有一个 <code>length</code> 属性，但没有任何数组的方法，函数可以通过此参数访问所有它被调用时传递给它的参数列表:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>这不是一种特别有用的模式，之后我们将学习如何给数组添加一个相似的方法达到同样的效果。</p><h2 id="返回-Return"><a href="#返回-Return" class="headerlink" title="返回(Return)"></a>返回(Return)</h2><p>如果函数调用时在前面加上了 <code>new</code> 前缀，且返回值不是一个对象，则返回 <code>this</code> (该新对象)</p><p>下一篇文章我们将学习关于函数的一些较高级的用法。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript语言精粹 - 对象篇</title>
      <link href="/2017/07/27/books/theGoodParts/1/"/>
      <url>/2017/07/27/books/theGoodParts/1/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>JavaScript 语言精粹 - 对象篇</p></blockquote><hr><p><em>Javascript</em> 的简单数据类型包括数字、字符串、布尔值、<code>null</code> 和 <code>undefined</code>，其他所有的值都是 _对象_。数字、字符串和布尔值是 ‘<code>貌似</code>’ 对象，因为它们拥有方法，但它们是不可变的。<br><em>Javascript</em> 中的 _对象_ 是可变的键控集合( <code>keyed collections</code> ),在 <em>Javascript</em> 中，数组、函数、正则表达式都是对象<br>_对象_ 是 <code>属性</code> 的容器，其中每个属性都拥有名字<code>(key)</code>和值<code>(value)</code>，属性名可以是包括空字符串在内的任意字符串，属性值可以是除了 <code>undefined</code> 之外的任何值<br><em>Javascript</em> 包含一种 <em>原型链</em> 的特性，允许对象继承另一个对象的属性，正确使用能减少对象初始化时消耗的时间和内存</p><h2 id="对象字面量-Object-Literals"><a href="#对象字面量-Object-Literals" class="headerlink" title="对象字面量(Object Literals)"></a>对象字面量(Object Literals)</h2><p>在对象字面量中，如果属性名是一个合法的 <code>Javascript</code> 标识符且不是保留字，则并不强制要求用引号括住属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stooge = &#123;</span><br><span class="line">  <span class="string">'first-name'</span>: <span class="string">'Amu'</span>,</span><br><span class="line">  last_name: <span class="string">'Amu'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="检索-Retrieval"><a href="#检索-Retrieval" class="headerlink" title="检索(Retrieval)"></a>检索(Retrieval)</h2><p>尝试从 <code>undefined</code> 的成员属性中取值将会导致 <code>TypeError</code>,可通过 <code>&amp;&amp;</code> 运算符避免错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flight = &#123;&#125;;</span><br><span class="line">flight.equipment; <span class="comment">// undefined</span></span><br><span class="line">flight.equipment.model; <span class="comment">// throw 'TypeError'</span></span><br><span class="line">flight.equipment &amp;&amp; flight.equipment.model; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="更新-Update"><a href="#更新-Update" class="headerlink" title="更新(Update)"></a>更新(Update)</h2><p>对象里的值可以通过赋值语句更新，如果属性名(<code>key</code>)存在，则属性值会被替换，否则该属性会被扩充到对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stooge[<span class="string">'first-name'</span>] = <span class="string">'Gu'</span>;</span><br><span class="line">stooge[<span class="string">'middle-name'</span>] = <span class="string">'Amu'</span>;</span><br></pre></td></tr></table></figure><h2 id="引用-Reference"><a href="#引用-Reference" class="headerlink" title="引用(Reference)"></a>引用(Reference)</h2><p>对象通过引用来传递，它们永远不会被复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = stooge;</span><br><span class="line">x.nickName = <span class="string">'Amu'</span>;</span><br><span class="line"><span class="comment">// 因为 x 和 stooge 是指向同一个对象的引用，所以 stooge.nickName 为 Amu</span></span><br><span class="line">stooge.nickName; <span class="comment">// Amu</span></span><br></pre></td></tr></table></figure><h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a>原型(Prototype)</h2><p>每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到 <code>Object.prototype</code>,它是 <code>JavaScript</code> 中的标配对象。<br>当你创建一个新对象时，你可以选择某个对象作为它的原型(<code>Object.create</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟Object.create</span></span><br><span class="line"><span class="keyword">if</span> (typeOf <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = o</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型链接在更新时不起作用，当我们对某个对象作出改变时，不会触及该对象的原型属性:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> another_stooge = <span class="built_in">Object</span>.create(stooge);</span><br><span class="line">another_stooge.nickName = <span class="string">'Ruby'</span>;</span><br><span class="line">stooge.nickName; <span class="comment">// 'Amu'</span></span><br></pre></td></tr></table></figure><p>原型关系是一种动态的关系，如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stooge.prefession = <span class="string">'coder'</span>;</span><br><span class="line">another_stooge.prefession; <span class="comment">// 'coder'</span></span><br></pre></td></tr></table></figure><h2 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h2><p><code>hasOwnProperty</code> 可以检查对象自身信息，如果对象拥有独有的属性，它将返回 <code>true</code>,<code>hasOwnProperty</code> 方法不会检查原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">another_stooge.hasOwnProperty(<span class="string">'nickName'</span>); <span class="comment">// true</span></span><br><span class="line">another_stooge.hasOwnProperty(<span class="string">'first-name'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="枚举-Enumeration"><a href="#枚举-Enumeration" class="headerlink" title="枚举(Enumeration)"></a>枚举(Enumeration)</h2><p><code>for in</code> 语句可用来遍历一个对象中的所有属性名.该枚举过程将会列出所有的属性 —— 包括函数和你可能不关心的原型中的属性，所以有必要过滤掉你不想要的值，最为常用的过滤器是 <code>hasOwnProperty</code> 方法，以及使用 <code>typeOf</code> 来排除函数，还有一种创建 <code>纯对象</code> 的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pureObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">pureObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>for in</code> 是无序的，如果需要正确顺序读取属性值，可以创建一个数组缓存属性名，然后按顺序遍历数组去读取对象属性值</p><h2 id="删除-Delete"><a href="#删除-Delete" class="headerlink" title="删除(Delete)"></a>删除(Delete)</h2><p><code>delete</code> 运算符用来删除对象的属性，如果对象包含该属性，则将其移除，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型中的属性透露出来:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">another_stooge.nickName; <span class="comment">// 'Ruby'</span></span><br><span class="line"><span class="keyword">delete</span> another_stooge.nickName;</span><br><span class="line">another_stooge.nickName; <span class="comment">// 'Amu',来自 stooge.nickName</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单向链表 - Linked list(一)</title>
      <link href="/2017/07/25/algorithm/linkedList1/"/>
      <url>/2017/07/25/algorithm/linkedList1/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现单向链表类</p></blockquote><hr><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展示了一个链表的结构<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" alt="单向链表"><br>相对传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素</p><h3 id="单向链表的创建"><a href="#单向链表的创建" class="headerlink" title="单向链表的创建"></a>单向链表的创建</h3><p>我们将创建一个类来表示单向链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向列表尾部添加一个新的项</span></span><br><span class="line">  append(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="keyword">this</span>.Node(element);</span><br><span class="line">    <span class="keyword">if</span> (!currentNode) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表中移除特定位置的元素</span></span><br><span class="line">  removeAt(position) &#123;</span><br><span class="line">    <span class="comment">// 判断position的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = currentNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    this.length--;</span><br><span class="line">    return currentNode.element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在任意位置插入一个元素</span><br><span class="line">  insert(position, element) &#123;</span><br><span class="line">    // 判断position的合法性</span><br><span class="line">    if (position &lt; 0 || position &gt; this.length) return false;</span><br><span class="line">    let index = 0;</span><br><span class="line">    let previousNode = null;</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line">    const node = new this.Node(element);</span><br><span class="line">    if (position === 0) &#123;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      this.head = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      previousNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    this.length++;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回传入元素的位置</span><br><span class="line">  indexOf(element) &#123;</span><br><span class="line">    let index = 0;</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line"></span><br><span class="line">    while (currentNode) &#123;</span><br><span class="line">      if (currentNode.element === element) &#123;</span><br><span class="line">        return index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 移除特定元素</span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    const index = this.indexOf(element);</span><br><span class="line">    return this.removeAt(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将单向链表转换为一个数组</span><br><span class="line">  toArray() &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    let currentNode = this.head;</span><br><span class="line">    while (currentNode) &#123;</span><br><span class="line">      arr.push(currentNode.element);</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 清空链表</span><br><span class="line">  clear() &#123;</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将单向链表转换为一个字符串</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.toArray().toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表是否为空</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.length === 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表长度</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回链表head</span><br><span class="line">  getHead() &#123;</span><br><span class="line">    return this.head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列 - queue</title>
      <link href="/2017/07/23/algorithm/queue/"/>
      <url>/2017/07/23/algorithm/queue/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现队列类</p></blockquote><hr><p>_队列_ 是遵循 <em>先进先出(FIFO)</em> 原则的一组有序的项，队列在尾部添加新元素，并从顶部移除元素，最新添加的元素必须排在队列的末尾</p><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><p>我们将创建一个类来表示队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加一个(或多个)新的项</span></span><br><span class="line">  enqueue(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列中的第一项,并返回移除的元素</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列中的第一个元素</span></span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断队列是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列里的所有元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出items元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列的创建"><a href="#优先队列的创建" class="headerlink" title="优先队列的创建"></a>优先队列的创建</h3><p>优先队列想比较于普通队列，它的每个元素均有一个优先权值，权值越大，优先级越前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  enqueue(element, priority) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items, isEmpty, size &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> items.push(&#123; element, priority &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priority &lt; items[i].priority) &#123;</span><br><span class="line">        <span class="keyword">return</span> items.splice(i, <span class="number">0</span>, &#123; element, priority &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    items.push(&#123; element, priority &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法和普通Queue实现相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈 - stack</title>
      <link href="/2017/07/22/algorithm/stack/"/>
      <url>/2017/07/22/algorithm/stack/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>使用 Javascript 实现栈类</p></blockquote><hr><p>_栈_ 是一种遵从 <em>后进先出(LIFO)</em> 原则的有序集合，新添加的或待删除的元素都保存在栈的末尾，称作 _栈顶_，另一端就叫 _栈底_，在栈里，新元素都靠近栈顶，旧元素都靠近栈底。</p><h3 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h3><p>我们将创建一个类来表示栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加一个(或几个)新元素到栈顶</span></span><br><span class="line">  push(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈顶元素，同时返回被移除的元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶的元素内容</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出items元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制转化为其他进制"><a href="#将十进制转化为其他进制" class="headerlink" title="将十进制转化为其他进制"></a>将十进制转化为其他进制</h3><p>创建了 <code>Stack</code> 类，让我们用其写一个小 demo，写一个将十进制转为其他进制的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNum, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rem = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> baseString = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> digits = <span class="string">'0123456789ABCDEF'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (decNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(decNum % base);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    decNum = <span class="built_in">Math</span>.floor(decNum / base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[remStack.pop()];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VueJs - 高阶组件实践</title>
      <link href="/2017/07/06/knowledge/vue/vuejs%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/07/06/knowledge/vue/vuejs%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>VueJs - 高阶组件实践</p></blockquote><hr><h3 id="Higher-Order-Components-hoc"><a href="#Higher-Order-Components-hoc" class="headerlink" title="Higher-Order Components (hoc)"></a>Higher-Order Components (hoc)</h3><p><a href="https://facebook.github.io/react/docs/higher-order-components.html" target="_blank" rel="noopener">Higher-Order Components</a> 高阶组件是 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 的一种高级应用，确切的说，高阶组件其实只是一个方法( <code>function</code> )，它接受一个组件，处理并返回另一个新组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>探讨前我们先理下需求，在 <code>组件化</code> 开发中，我们往往会遇到这样一种情况：完全不同的两个组件，可能会需要拥有一个或 N 个相同的功能，我们以 <code>input number</code> 为例，在按钮点击时我们需要让其 <code>console</code> 当前按钮的 <code>counter data</code>，并在按钮前面加上 <code>hoc-</code> 的字眼，这时我们有两种选择：</p><ol><li>直接新建一个按钮组件，让其包含以上功能</li><li>使用 <code>hoc</code> 函数处理组件，并返回新组件供使用</li></ol><p>为遵循 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY (Don’t repeat yourself)</a> 规则，我们选择 <code>hoc</code> 来实现改需求</p><h3 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add-btn.js</span></span><br><span class="line">&lt;template lang=<span class="string">"html"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"add-btn"</span> @click=<span class="string">"handleClick"</span>&gt;add: &#123;&#123;counter&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'add-btn'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter++</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce-btn.js</span></span><br><span class="line">&lt;template lang=<span class="string">"html"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"reduce-btn"</span> @click=<span class="string">"handleClick"</span>&gt;reduce: &#123;&#123;counter&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'reduce-btn'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter--</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HOC-实践"><a href="#HOC-实践" class="headerlink" title="HOC 实践"></a>HOC 实践</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'hoc'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...container.props</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      container</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleChange(data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, data);</span><br><span class="line">        <span class="keyword">const</span> &#123; $options, counter &#125; = <span class="keyword">this</span>.$children[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`%s's counter is %d`</span>, $options.name, counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = &#123;</span><br><span class="line">        props: <span class="keyword">this</span>.$props</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          hoc-</span><br><span class="line">          &lt;container onChange=&#123;<span class="keyword">this</span>.handleChange&#125; &#123;...data&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;add-btn @change=<span class="string">"handleChange"</span> a=<span class="string">"b"</span>/&gt;</span><br><span class="line">    &lt;reduce-btn @change=<span class="string">"handleChange"</span>/&gt;</span><br><span class="line">    &lt;div&gt;total: &#123;&#123;total&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import hoc from './</span>hoc.js<span class="string">'</span></span><br><span class="line"><span class="string">import AddBtn from '</span>./AddBtn.vue<span class="string">'</span></span><br><span class="line"><span class="string">import ReduceBtn from '</span>./ReduceBtn.vue<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: '</span>app<span class="string">',</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    '</span>add-btn<span class="string">': hoc(AddBtn),</span></span><br><span class="line"><span class="string">    '</span>reduce-btn<span class="string">': hoc(ReduceBtn)</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      total: 0</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    handleChange (number) &#123;</span></span><br><span class="line"><span class="string">      this.total += number</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Emacs 官方教程总结</title>
      <link href="/2017/06/30/apps/Emacs%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/30/apps/Emacs%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>Emacs 官方教程总结</p></blockquote><hr><h3 id="读官方教程"><a href="#读官方教程" class="headerlink" title="读官方教程"></a>读官方教程</h3><p>按以下步骤阅读教程:</p><ul><li>不安装任何插件打开 <code>Emacs</code>, 比如在 <code>Shell</code> 中运行命令 <code>emacs -nw -Q</code></li><li>同时按下 <code>Alt</code> 和 <code>X</code> 健, 输入 <code>help-with-tutorial</code> (类似快捷键后文简写为 <code>M-x help-with-tutorial</code> 代替), 回车</li></ul><h3 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h3><ul><li><code>C</code> 表示按下 <code>Ctrl</code> 键, <code>M</code> 表示按下 <code>Alt</code> 键</li><li><code>M-x my-command</code> 表示同时按下 <code>Alt</code> 和 <code>X</code>, 输入 “my-command”, 然后回车</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="翻页浏览"><a href="#翻页浏览" class="headerlink" title="翻页浏览"></a>翻页浏览</h4><ul><li><code>C-v</code> 向前移动一屏</li><li><code>M-v</code> 向后移动一屏</li><li><code>C-l</code> 重绘屏幕，并将光标所在行置于屏幕的中央</li></ul><h4 id="基本的光标控制（BASIC-CURSOR-CONTROL）"><a href="#基本的光标控制（BASIC-CURSOR-CONTROL）" class="headerlink" title="基本的光标控制（BASIC CURSOR CONTROL）"></a>基本的光标控制（BASIC CURSOR CONTROL）</h4><ul><li>C-f(forward) 向右移动一个字符</li><li>C-b(backward) 向左移动一个字符</li><li>M-f 向右移动一个词【对中文是移动到下一个标点符号】</li><li>M-b 向左移动一个词【对中文是移动到上一个标点符号】</li><li>C-n(next) 移动到下一行</li><li>C-p(previous) 移动到上一行</li><li>C-a 移动到行首</li><li>C-e 移动到行尾</li><li>M-a 移动到句首</li><li>M-e 移动到句尾</li><li>M-&lt; 移动到文本开头</li><li>M-&gt; 移动到文本末尾</li></ul><p>使用这些命令而不使用方向键进行光标移动的理由是：</p><ul><li>它们在任何键盘上都能用</li><li>当你熟练使用 Emacs 之后，你会发现用这些组合键比用方向键要快得多，因为你<br>的手不需要离开打字区</li><li>一旦你习惯了使用这些组合键，你也可以很容易地适应其它更高级的光标移动命令</li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul><li><code>C-u 8 C-f</code> 会向前移动 8 个字符</li></ul><h4 id="在-EMACS-失去响应的时候（WHEN-EMACS-IS-HUNG）"><a href="#在-EMACS-失去响应的时候（WHEN-EMACS-IS-HUNG）" class="headerlink" title="在 EMACS 失去响应的时候（WHEN EMACS IS HUNG）"></a>在 EMACS 失去响应的时候（WHEN EMACS IS HUNG）</h4><ul><li><code>C-g</code> 终止命令</li></ul><h4 id="插入与删除（INSERTING-AND-DELETING）"><a href="#插入与删除（INSERTING-AND-DELETING）" class="headerlink" title="插入与删除（INSERTING AND DELETING）"></a>插入与删除（INSERTING AND DELETING）</h4><ul><li>C-u 次数 字符 重复输入多少次的相同字符</li><li>backspace 删除光标前的一个字符</li><li>C-d 删除光标后的一个字符</li><li>M-backspace 移除光标前的一个词</li><li>M-d 移除光标后的一个词</li><li>C-k 移除光标到行尾间的字符</li><li>M-k 移除光标到句尾间的字符</li><li>C-@ 移动光标选择要删除的文本</li><li>C-w 剪切选中文本</li><li>M-w 拷贝选中的文本</li><li>C-g 取消选择</li><li>C-x h 全选</li><li>C-w 剪切选中文本</li><li>M-w 拷贝选中的文本</li><li>被移除的可以被重新插入在任何位置，被删除的只能撤销删除。</li><li>C-y 在光标处插入最后移除的文字</li><li>M-y 召回再前一次移除的文字</li></ul>]]></content>
      
      <categories>
          
          <category> 效率神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现JavaScript动画序列播放</title>
      <link href="/2017/06/22/knowledge/%E5%AE%9E%E7%8E%B0JavaScript%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97%E6%92%AD%E6%94%BE/"/>
      <url>/2017/06/22/knowledge/%E5%AE%9E%E7%8E%B0JavaScript%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97%E6%92%AD%E6%94%BE/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/sixty-lines-of-code-animation.html" target="_blank" rel="noopener">《用 65 行代码实现 JavaScript 动画序列播放》</a> 读后总结</p></blockquote><hr><h3 id="performance-now-获取当前时间"><a href="#performance-now-获取当前时间" class="headerlink" title="performance.now() 获取当前时间"></a>performance.now() 获取当前时间</h3><p>在新的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a> 规范中，<code>frame</code> 回调的参数 <code>timestamp</code> 是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">DOMHighResTimeStamp</a> 对象，它比 <code>Date</code> 的计时要更精确（可以精确到纳秒）。因此获取时间我们优先使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" target="_blank" rel="noopener">performance.now()</a>，如果浏览器不支持 <code>performance.now()</code>，我们再降级使用 <code>Date.now()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nowtime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> performance !== <span class="string">'undefined'</span> &amp;&amp; performance.now) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now ? <span class="built_in">Date</span>.now() : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requestAnimationFrame-polyfill"><a href="#requestAnimationFrame-polyfill" class="headerlink" title="requestAnimationFrame polyfill"></a>requestAnimationFrame polyfill</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.requestAnimationFrame === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//polyfill</span></span><br><span class="line">      <span class="keyword">this</span>::callback(nowtime());</span><br><span class="line">    &#125;, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">qId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clearTimeout(qId);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Animator-ES6-实现"><a href="#Animator-ES6-实现" class="headerlink" title="Animator ES6 实现"></a>Animator ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(duration, update, easing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    <span class="keyword">this</span>.update = update;</span><br><span class="line">    <span class="keyword">this</span>.easing = easing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; duration, update, easing &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> qId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        startTime = startTime || timestamp;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">Math</span>.min(<span class="number">1.0</span>, (timestamp - startTime) / duration);</span><br><span class="line"></span><br><span class="line">        self::update(easing ? easing(p) : p, p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">          qId = requestAnimationFrame(step);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(self);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        cancelAnimationFrame(qId);</span><br><span class="line">        self::update(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        reject(<span class="string">'User canceled!'</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      qId = requestAnimationFrame(step);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 能够传入新的 easing，并返回新的 Animator 对象，这样我们就可以在原动画的基础上扩展我们的动画效果</span></span><br><span class="line">  ease = <span class="function"><span class="params">easing</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Animator(<span class="keyword">this</span>.duration, <span class="keyword">this</span>.update, easing);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS动画基础案例</title>
      <link href="/2017/06/21/knowledge/JS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/06/21/knowledge/JS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a> 学习笔记，将以 ES6 的语法实现原文案例</p></blockquote><hr><h3 id="动画的简易封装"><a href="#动画的简易封装" class="headerlink" title="动画的简易封装"></a>动画的简易封装</h3><p>为了实现更加复杂的动画，我们可以将动画进行简易的封装，要进行封装，我们先要抽象出动画相关的要素：</p><ul><li>动画时长：\(T = duration\)</li><li>动画进程：\( p = \frac{t}{T}\ (p \in [0, 1])\)</li><li>动画量子 easing：\(e = f(p)\)</li><li>动画方程：\([x, y] = G(e) = G(f(p))\)</li><li>动画生命周期：开始、进行中、结束。</li></ul><p><em>动画的简易封装</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param  &#123;Number&#125;   duration 动画持续时间</span></span><br><span class="line"><span class="comment">   * @param  &#123;Function&#125; progress 过程处理函数，回调参数为 动画量子easing 及 动画进度 p</span></span><br><span class="line"><span class="comment">   * @param  &#123;Function&#125; easing   easing处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(duration, progress, easing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    <span class="keyword">this</span>.progress = progress;</span><br><span class="line">    <span class="keyword">this</span>.easing =</span><br><span class="line">      easing ||</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">this</span>.rAF = <span class="built_in">window</span>.requestAnimationFrame; <span class="comment">// rAF 需要做兼容性判断</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start = <span class="function"><span class="params">finished</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> &#123; duration, progress, easing, rAF &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    rAF(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 记录动画进度</span></span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">Date</span>.now() - startTime) / duration;</span><br><span class="line">      <span class="keyword">let</span> next = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据进度及finished参数，选择不同的 progress 回调方式，回调参数为 动画量子easing 及 动画进度 p</span></span><br><span class="line">      <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        progress(easing(p), p);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> finished === <span class="string">'function'</span>) &#123;</span><br><span class="line">          next = finished() === <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next = finished === <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next) &#123;</span><br><span class="line">          progress(easing(<span class="number">1.0</span>), <span class="number">1.0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          startTime += duration;</span><br><span class="line">          progress(easing(p), p);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否继续执行定时器</span></span><br><span class="line">      <span class="keyword">if</span> (next) rAF(step);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码里，我们封装出一个简易的动画类 <code>Animator</code>, 这个类的构造器接收三个参数，分别是 <code>duration</code>, <code>process</code> 和 <code>easing</code>。它产生一个对象，包含一个 <code>start</code> 方法，这个方法用指定 <code>duration</code>、<code>process</code> 和 <code>easing</code> 执行动画。<br><code>start</code> 方法包含一个参数，这个参数是一个布尔类型或者回调函数，当动画结束的时候，如果这个参数是回调函数，将执行这个函数，它的返回值如果不是 <code>false</code> 那么结束动画，否则循环播放动画。</p><h3 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h3><p>在构造更复杂的动画的时候，为了更方便使用，避免回调嵌套，我们可以再实现一个动画队列类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(animators) &#123;</span><br><span class="line">    <span class="keyword">this</span>.animators = animators || [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  append = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.animators.push(...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  flush = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; animators &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> animator = animators.shift();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animator <span class="keyword">instanceof</span> Animator) &#123;</span><br><span class="line">          animator.start(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">              play();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          self::animator();</span><br><span class="line">          <span class="keyword">if</span> (animators.length) &#123;</span><br><span class="line">            play();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      play();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础案例"><a href="#基础案例" class="headerlink" title="基础案例"></a>基础案例</h3><p>我们尝试使用上面设计的动画类来构造连续播放的动画：</p><p><a href="https://jsfiddle.net/Amu_xh/3uvpLj2z/2/" target="_blank" rel="noopener">让滑块先向右然后再向下运动</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;tx&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translate(100px, <span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  a1.start(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    a2.start();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/Amu_xh/q8fycj2p/" target="_blank" rel="noopener">让滑块沿一个矩形边界运动</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;tx&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * p;</span><br><span class="line">  block.style.transform = <span class="string">`translate(100px, <span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="number">100</span> * (<span class="number">1</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translate(<span class="subst">$&#123;tx&#125;</span>px, 100px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a4 = <span class="keyword">new</span> Animator(<span class="number">1000</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">100</span> * (<span class="number">1</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line">  animators.append(a1, a2, a3, a4);</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意到我们的动画队列除了支持 Animator 对象外，还支持普通的函数，因此我们可以组合起来做一些复杂的运动：<br><a href="https://jsfiddle.net/Amu_xh/41Lwknxs/" target="_blank" rel="noopener">弹跳的小球</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(<span class="number">1414</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">200</span> * p * p;</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(<span class="number">1414</span>, p =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="number">200</span> - <span class="number">200</span> * p * (<span class="number">2</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line">  animators.append(a1, a2, <span class="function"><span class="keyword">function</span> <span class="title">a3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.append(a1, a2, a3);</span><br><span class="line">  &#125;);</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以再加入更复杂的效果：<br>[弹跳的小球 - 带阻尼效果]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> T = <span class="number">1414</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animator(T, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = (<span class="keyword">this</span>.duration * <span class="number">200</span>) / T;</span><br><span class="line">  <span class="keyword">const</span> ty = s * (p * p - <span class="number">1</span>);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> Animator(T, <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = (<span class="keyword">this</span>.duration * <span class="number">200</span>) / T;</span><br><span class="line">  <span class="keyword">const</span> ty = -s * p * (<span class="number">2</span> - p);</span><br><span class="line">  block.style.transform = <span class="string">`translateY(<span class="subst">$&#123;ty&#125;</span>px)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animators = <span class="keyword">new</span> AnimationQueue();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a2.duration *= <span class="number">0.7</span>;</span><br><span class="line">  <span class="keyword">if</span> (a2.duration &lt;= <span class="number">0.0001</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    animators.animators.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animators.append(a1, foo, a2, <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a1.duration *= <span class="number">0.7</span>;</span><br><span class="line">  <span class="keyword">this</span>.append(a1, foo, a2, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  animators.flush();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于动画，你需要知道</title>
      <link href="/2017/06/20/knowledge/%E5%85%B3%E4%BA%8E%E5%8A%A8%E7%94%BB%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/"/>
      <url>/2017/06/20/knowledge/%E5%85%B3%E4%BA%8E%E5%8A%A8%E7%94%BB%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a> 读后总结</p></blockquote><hr><h3 id="简单的-JS-动画"><a href="#简单的-JS-动画" class="headerlink" title="简单的 JS 动画"></a>简单的 JS 动画</h3><p>在浏览器里，动画实现的基本原理非常简单明了，其实就是 <em>采用定时器改变显示元素的一些属性的过程</em>。不管是 JavaScript 操作 DOM 的动画，还是 CSS3 动画，还是 Canvas 动画，或者 SVG 动画，区别只是使用的 API、何种定时器，影响什么环境（DOM/Canvas/SVG/WebGL）。</p><p><a class="jsbin-embed" href="//code.h5jun.com/wev/6/embed?output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deg = <span class="number">0</span>;</span><br><span class="line">block.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.style.transform = <span class="string">'rotate('</span> + deg++ + <span class="string">'deg)'</span>;</span><br><span class="line">    requestAnimationFrame(change);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面例子使用了 定时器<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a>，但是其并不是最佳的实现方法，下面让我们来解析其存在的问题:</p><ol><li>因为 <code>JavaScript</code> 是单线程，如果 <code>requestAnimationFrame</code> 被其他任务阻塞了，动画就会变慢(刷新率降低)</li><li>假定每次触发 <code>requestAnimationFrame</code> 时间一定，我们通过上例 <em>定义速度</em> 的方式来改变动画，会导致我们很难控制动画时间和动画的幅度，像前面这种匀速运动其实还好，如果做一些复杂的变速运动，按照我们的定义方式，我们本该设置的元素属性值将会类似于求积分，但是事实上时间又不连贯。</li></ol><h3 id="动画是“位移”关于“时间”的函数"><a href="#动画是“位移”关于“时间”的函数" class="headerlink" title="动画是“位移”关于“时间”的函数"></a>动画是“位移”关于“时间”的函数</h3><p>动画，是 <em>位移关于时间的函数</em> : \(s = f(t)\)<br>所以，我们<em>不该</em>采用增量的方式来执行动画，为了更精确地控制动画，更合适的方式是<em>将动画与时间联系起来</em></p><h4 id="动画与时间关联"><a href="#动画与时间关联" class="headerlink" title="动画与时间关联"></a>动画与时间关联</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="built_in">Date</span>.now() - startTime;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已执行时间: %fms'</span>, current);</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(change);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动画时间归一化表示"><a href="#动画时间归一化表示" class="headerlink" title="动画时间归一化表示"></a>动画时间归一化表示</h4><p>动画通常情况下有终止时间，如果是循环动画，我们也可以看做特殊的——当动画达到终止时间之后，重新开始动画。因此，我们可以将动画时间 <em>归一(Normalize)</em> 表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params">duration, isLoop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p =&gt; progress 动画进程数</span></span><br><span class="line">    <span class="keyword">var</span> p = (<span class="built_in">Date</span>.now() - startTime) / duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环归一化</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLoop) &#123;</span><br><span class="line">        startTime += duration;</span><br><span class="line">        p -= <span class="number">1.0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="number">1.0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已执行进度: %f'</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">      requestAnimationFrame(change);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画算子：-easing"><a href="#动画算子：-easing" class="headerlink" title="动画算子： easing"></a>动画算子： easing</h3><p>匀速运动、匀加速运动、匀减速运动、圆周运动唯一的区别仅仅在于位移方程：</p><ul><li>匀速运动：\(s_p = S \cdot P\)</li><li>匀加速运动：\(s_p = S \cdot P^2\)</li><li>匀减速运动：\(s_p = S \cdot P \cdot (2 - P)\)</li><li>圆周运动 x 轴：\(s_p = S \cdot cos(ωt)\)</li><li>圆周运动 y 轴：\(s_p = S \cdot sin(ωt)\)</li></ul><p>\(s_p\) 为当前位移量， \(S\) 为动画总位移量， \(P\) 为动画进程</p><p>我们把共同的部分 S 去掉，得到一个关于 p 的方程 \(e_p = E(p)\)，这个方程我们称为动画的算子(easing)，它决定了动画的性质。</p><ul><li>匀速算子：\(e_p = P\)</li><li>匀加速算子：\(e_p = P^2\)</li><li>匀减速算子：\(e_p = P \cdot (2 - P)\)</li><li>圆周算子 x 轴： \(e_p = cos(ωt)\)</li><li>圆周算子 y 轴： \(e_p = sin(ωt)\)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己曾尝试过写惯性动画，之前的方案是按照增量方式进行，但因为动画涉及元素多，计算量大，导致在一些机型会特别的卡（当然不排除代码问题），昨天在翻阅 <a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">iScroll</a> 源码的时候，才了解到了 <em>动画量子(easing)</em> 的存在，在阅读完这篇文章后，对 <em>动画量子</em> 又有了进一步的理解，之后将继续跟随这篇文章，对 js 动画做一个简易封装。</p><blockquote><p>原文链接 <a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">《关于动画，你需要知道的》</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 最新特性实现的三大黑科技</title>
      <link href="/2017/06/19/knowledge/JavaScript%E6%9C%80%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E5%A4%A7%E9%BB%91%E7%A7%91%E6%8A%80/"/>
      <url>/2017/06/19/knowledge/JavaScript%E6%9C%80%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E5%A4%A7%E9%BB%91%E7%A7%91%E6%8A%80/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">《JavaScript 最新特性实现的三大黑科技》</a> 读后总结</p></blockquote><hr><h3 id="依次执行多项异步任务"><a href="#依次执行多项异步任务" class="headerlink" title="依次执行多项异步任务"></a>依次执行多项异步任务</h3><p><a class="jsbin-embed" href="//code.h5jun.com/dep/1/embed?console">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">taskReducer</span>(<span class="params">promise, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> promise;</span><br><span class="line">  <span class="keyword">return</span> action(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`task <span class="subst">$&#123;i&#125;</span> done`</span>);</span><br><span class="line">  <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[asyncTask, asyncTask, asyncTask].reduce(taskReducer, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>taskReducer</code> 的两个参数是 <code>promise</code> 和 <code>action</code>，<code>promise</code> 是代表当前任务的 <code>promise</code>，而 <code>action</code> 是下一个要执行的任务。我们可以 <code>await</code> 当前 <code>promise</code> 执行当前任务，然后将执行结果传给下一个 <code>action</code> 就可以了。</p><h3 id="generator-与-async-await-一同使用"><a href="#generator-与-async-await-一同使用" class="headerlink" title="generator 与 async/await 一同使用"></a>generator 与 async/await 一同使用</h3><p><a class="jsbin-embed" href="//code.h5jun.com/woge/2/embed?console">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">promise, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> promise;</span><br><span class="line">  <span class="keyword">return</span> action(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(++i), <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">continuous</span>(<span class="params">...functors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> functors.reduce(reducer, input);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">timing</span>(<span class="params">count = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> tick;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">continuous(...timing(<span class="number">10</span>))(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这部分没明白这么使用的优势在哪，<code>generator</code> 使用部分其实就是讲 <code>tick</code> 函数装入一个数组内，后使用 <code>continuous</code> 方法对其进行 <code>reduce</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将timing改为这样也可以运行，所以不明白使用 generator 的优势在哪</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">count = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    arr.push(tick);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Proxy-实现-PHP-中的常用“魔术方法”"><a href="#使用-Proxy-实现-PHP-中的常用“魔术方法”" class="headerlink" title="使用 Proxy 实现 PHP 中的常用“魔术方法”"></a>使用 Proxy 实现 PHP 中的常用“魔术方法”</h3><p>因为之前并没有对 <code>Proxy</code> 有过了解，所以另开了一篇文章对其做了下小总结 <a href="/2017/06/20/javascript/ES6-初识Proxy/">ES6 - 初识 Proxy</a><br>文章例子在对象构造的时候，分别“代理”对象实例的属性 get 和 set 方法，如果对象上已存在某个属性或方法，代理直接返回或操作该属性。否则，判断对象上是否有 <code>__get</code>、<code>__set</code> 或者 <code>__call</code> 方法，有的话，做相应的处理相当于是使用 <code>Proxy</code> “重载”对象的属性和方法读写。<br>这种加工并返回新类的方式，有函数式编程的感觉，我们也可以使用 <code>修饰器 Decorators</code> 来对其封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@magical</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    __call(key, ...args)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前写过相关文章 <a href="/2017/05/29/javascript/ES7修饰器/">ES7 修饰器</a></p><p>以上就是对 <a href="https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">《JavaScript 最新特性实现的三大黑科技》</a> 文章的读后感，谢谢原作者的分享。</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数节流 - throttle</title>
      <link href="/2017/06/07/knowledge/throttle/"/>
      <url>/2017/06/07/knowledge/throttle/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>函数节流 - throttle</p></blockquote><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在项目开发中，经常会遇到某一个函数会因 <em>事件回调</em> or <em>用户操作</em> 而频繁被调起的情况，例如 <code>onscroll</code>、<code>ontouchmove</code> 等，高频率的函数触发会导致性能的下降甚至让浏览器直接崩溃。so，怎么解决？函数节流就是其中的一个方法。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>函数节流的原理挺简单的，估计大家都想到了，那就是定时器。当触发一个函数时，先 setTimout 让这个函数延迟一会再执行，如果在这个时间间隔内又触发了该函数，那我们就 clear 掉原来的定时器，重新定义一个新的定时器，这样便能控制函数不被高频触发了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, context, delay, value</span>) </span>&#123;</span><br><span class="line">  clearTimeout(fn.timeoutId);</span><br><span class="line">  fn.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn.call(context, value);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>throttle</code>函数将定时器 id 作为自身的一个属性，当 <code>delay</code> 时间段内被再次被调用的时候，将会 <code>clear</code> 掉上一个定制器，并重新定义新的定时器。</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阅读精选 - 2017/06</title>
      <link href="/2017/06/01/reading/2017-06/"/>
      <url>/2017/06/01/reading/2017-06/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>2017 年 6 月阅读记录</p></blockquote><hr><p>06-01: 技术文章 - <a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程 - 阮一峰</a></p><p>06-02: 技术文章 - <a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">Pointfree 编程风格指南 - 阮一峰</a><br>读后一句话：文章例子均使用 <em>Ramda</em> 库，对该库有一定了解后再理解会比较好</p><p>06-03: 技术文章 - <a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="noopener">Ramda 函数库参考教程</a></p><p>06-19: 技术文章 - <a href="https://www.h5jun.com/post/three-black-tech-in-modern-js.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">JavaScript 最新特性实现的三大黑科技</a><br>读后一篇文：<a href="/2017/06/19/javascript/JavaScript最新特性实现的三大黑科技/">JavaScript 最新特性实现的三大黑科技</a></p><p>06-20: 技术文章 - <a href="https://www.h5jun.com/post/animations-you-should-know.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">关于动画，你需要知道的</a><br>读后文：</p><ul><li><a href="/2017/06/20/javascript/关于动画你需要知道的/">关于动画，你需要知道的</a></li><li><a href="/2017/06/21/javascript/JS动画基础案例/">JS 动画基础案例</a></li></ul><p>06-22: 技术文章 - <a href="https://www.h5jun.com/post/sixty-lines-of-code-animation.html" target="_blank" rel="noopener">用 65 行代码实现 JavaScript 动画序列播放</a><br>读后一篇文：<a href>实现 JavaScript 动画序列播放</a></p><h2 id="06-30-概念认知-什么是自由软件？"><a href="#06-30-概念认知-什么是自由软件？" class="headerlink" title="06-30: 概念认知 - 什么是自由软件？"></a>06-30: 概念认知 - <a href="https://www.gnu.org/philosophy/free-sw.zh-cn.html" target="_blank" rel="noopener">什么是自由软件？</a></h2>]]></content>
      
      <categories>
          
          <category> 阅读精选 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>源码解析 - classnames</title>
      <link href="/2017/05/31/sourceAnalysis/classnames/"/>
      <url>/2017/05/31/sourceAnalysis/classnames/</url>
      <content type="html"><![CDATA[<hr><blockquote><p><a href="https://github.com/JedWatson/classnames" target="_blank" rel="noopener">classnames</a> - A simple javascript utility for conditionally joining classNames together</p></blockquote><hr><p><a href="https://github.com/JedWatson/classnames" target="_blank" rel="noopener">classnames</a> 是一个按需生成字符串的库，在 <code>react</code> 动态渲染 <code>className</code> 时极为有用，下面让我们一起看看 <a href="https://github.com/JedWatson/classnames/tree/v2.2.5" target="_blank" rel="noopener">classnames v2.2.5</a> 源码实现吧</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>classnames</code> 提供三种模式：</p><ol><li><a href="#普通模式-index-js">普通模式</a>，对应文件 <code>/index.js</code></li><li><a href="#绑定模式-bind-js"><code>bind</code> 绑定模式</a>，该模式会根据绑定对象 <code>key</code> 值真否性，判断是否添加对应的 <code>value</code> 字符串，可用于 <code>css modules</code> 或类似的抽象类名模式，对应文件 <code>/bind.js</code></li><li><a href="#去重模式-dedupe-js"><code>dedupe</code> 去重模式</a>，该模式会覆盖重复属性，速度比普通模式慢 <em>5 倍</em> 左右，对应文件 <code>/dedupe.js</code></li></ol><h2 id="普通模式-index-js"><a href="#普通模式-index-js" class="headerlink" title="普通模式 - index.js"></a>普通模式 - index.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo-bar'</span></span><br><span class="line">classNames(&#123; <span class="string">'foo-bar'</span>: <span class="literal">false</span> &#125;); <span class="comment">// =&gt; ''</span></span><br><span class="line">classNames(&#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(&#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lots of arguments of various types</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span>, <span class="attr">duck</span>: <span class="literal">false</span> &#125;, <span class="string">'baz'</span>, &#123; <span class="attr">quux</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'foo bar baz quux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// other falsy values are just ignored</span></span><br><span class="line">classNames(<span class="literal">null</span>, <span class="literal">false</span>, <span class="string">'bar'</span>, <span class="literal">undefined</span>, <span class="number">0</span>, <span class="number">1</span>, &#123; <span class="attr">baz</span>: <span class="literal">null</span> &#125;, <span class="string">''</span>); <span class="comment">// =&gt; 'bar 1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays will be recursively flattened as per the rules above:</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'b'</span>, &#123; <span class="attr">c</span>: <span class="literal">true</span>, <span class="attr">d</span>: <span class="literal">false</span> &#125;];</span><br><span class="line">classNames(<span class="string">'a'</span>, arr); <span class="comment">// =&gt; 'a b c'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心源码</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> hasOwn = &#123;&#125;.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classNames</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 字符串缓存数组</span></span><br><span class="line">  <span class="keyword">var</span> classes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历传入参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数类型</span></span><br><span class="line">    <span class="keyword">var</span> argType = <span class="keyword">typeof</span> arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argType === <span class="string">'string'</span> || argType === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="comment">// 字符串或数字类型则添加到字符串数组后</span></span><br><span class="line">      classes.push(arg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arg)) &#123;</span><br><span class="line">      <span class="comment">// 数组类型则引用自身进行递归操作</span></span><br><span class="line">      classes.push(classNames.apply(<span class="literal">null</span>, arg));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argType === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// 对象类型则遍历key值，并判断value是否为真，后将真值value的key字符串插入字符串数组内</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123;</span><br><span class="line">          classes.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回字符串内容</span></span><br><span class="line">  <span class="keyword">return</span> classes.join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定模式-bind-js"><a href="#绑定模式-bind-js" class="headerlink" title="绑定模式 - bind.js"></a>绑定模式 - bind.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> classNames = <span class="built_in">require</span>(<span class="string">'classnames/bind'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> styles = &#123;</span><br><span class="line">  foo: <span class="string">'abc'</span>,</span><br><span class="line">  bar: <span class="string">'def'</span>,</span><br><span class="line">  baz: <span class="string">'xyz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cx = classNames.bind(styles);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> className = cx(<span class="string">'foo'</span>, [<span class="string">'bar'</span>], &#123; <span class="attr">baz</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; "abc def xyz"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="comment">// bind.js</span></span><br><span class="line"><span class="comment">// 绑定模式与普通模式的区别在于插入字符串时做了 this &amp;&amp; this[arg] || arg 的判断</span></span><br><span class="line"><span class="comment">// 此时的this会指向 classNames.bind(obj) 里的 obj 对象</span></span><br><span class="line"><span class="comment">// 若obj[arg]对应value存在，则取此value，否则取arg本身</span></span><br><span class="line"><span class="keyword">if</span> (argType === <span class="string">'string'</span> || argType === <span class="string">'number'</span>) &#123;</span><br><span class="line">  classes.push((<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>[arg]) || arg);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arg)) &#123;</span><br><span class="line">  classes.push(classNames.apply(<span class="keyword">this</span>, arg));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (argType === <span class="string">'object'</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123;</span><br><span class="line">      classes.push((<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>[key]) || key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去重模式-dedupe-js"><a href="#去重模式-dedupe-js" class="headerlink" title="去重模式 - dedupe.js"></a>去重模式 - dedupe.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> classNames = <span class="built_in">require</span>(<span class="string">'classnames/dedupe'</span>);</span><br><span class="line"></span><br><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// =&gt; 'foo bar'</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">foo</span>: <span class="literal">false</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; 'bar'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="comment">// dedupe.js</span></span><br><span class="line"><span class="comment">// dedupe版本主要思想是：实例化一个空对象接收传参的字符串值，</span></span><br><span class="line"><span class="comment">// 字符串作为key，value为布尔值，添加则为true，不保留则为false，</span></span><br><span class="line"><span class="comment">// 这样便能达到后者覆盖前者的功能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE，隔离作用域</span></span><br><span class="line"><span class="keyword">var</span> classNames = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过Object.create(null)生成空对象，去除 &#123;&#125; 中继承 Object 属性对程序的影响，省去了后面对对象做 hasOwnPropertyhas 的检查</span></span><br><span class="line">  <span class="comment">// http://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull#answer-21079232</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">StorageObject</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  StorageObject.prototype = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_parseArray</span>(<span class="params">resultSet, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="comment">// 对每一项数据进行解析</span></span><br><span class="line">      _parse(resultSet, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hasOwn = &#123;&#125;.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数字解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_parseNumber</span>(<span class="params">resultSet, num</span>) </span>&#123;</span><br><span class="line">    resultSet[num] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_parseObject</span>(<span class="params">resultSet, object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> object) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasOwn.call(object, k)) &#123;</span><br><span class="line">        <span class="comment">// 对不需要添加的属性设置布尔值，而不是选择delete掉改key</span></span><br><span class="line">        <span class="comment">// https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/#de-referencing-misconceptions</span></span><br><span class="line">        resultSet[k] = !!object[k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> SPACE = <span class="regexp">/\s+/</span>;</span><br><span class="line">  <span class="comment">// 字符串解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_parseString</span>(<span class="params">resultSet, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = str.split(SPACE);</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      resultSet[array[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按不同类型区分解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_parse</span>(<span class="params">resultSet, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> argType = <span class="keyword">typeof</span> arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 'foo bar'</span></span><br><span class="line">    <span class="keyword">if</span> (argType === <span class="string">'string'</span>) &#123;</span><br><span class="line">      _parseString(resultSet, arg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ['foo', 'bar', ...]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arg)) &#123;</span><br><span class="line">      _parseArray(resultSet, arg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &#123; 'foo': true, ... &#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argType === <span class="string">'object'</span>) &#123;</span><br><span class="line">      _parseObject(resultSet, arg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// '130'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argType === <span class="string">'number'</span>) &#123;</span><br><span class="line">      _parseNumber(resultSet, arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_classNames</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过新变量缓存 arguments，以保证 arguments 不被传递或暴露</span></span><br><span class="line">    <span class="comment">// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> classSet = <span class="keyword">new</span> StorageObject();</span><br><span class="line">    _parseArray(classSet, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> list = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历缓存实例，将true值key插入到字符串数组内</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> classSet) &#123;</span><br><span class="line">      <span class="keyword">if</span> (classSet[k]) &#123;</span><br><span class="line">        list.push(k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串</span></span><br><span class="line">    <span class="keyword">return</span> list.join(<span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _classNames;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>因为代码使用了 <code>Array.isArray</code>，故不支持 ie8 以下浏览器，若需要使用，则需要自行添加对应的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?v=example" target="_blank" rel="noopener"><code>Array.isArray Polyfill</code></a>，而原文档里面提到代码还使用了 <code>Object.keys</code>，但是在该最新版本中暂未发现次方法，贴上对应 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener"><code>Object.keys Polyfill</code></a></p>]]></content>
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阅读精选 - 2017/05</title>
      <link href="/2017/05/30/reading/2017-05/"/>
      <url>/2017/05/30/reading/2017-05/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>2017 年 5 月阅读记录</p></blockquote><hr><p>05-30: 技术文章 - <a href="http://www.zcfy.cc/article/a-detailed-introduction-to-webpack-ndash-smashing-magazine-2974.html" target="_blank" rel="noopener">Webpack 最详解</a><br>读后一句话：基础篇，干货内容不多</p><hr><p>05-27: 技术文章 - <a href="https://zhuanlan.zhihu.com/p/27127139" target="_blank" rel="noopener">深入理解 JavaScript 错误与调用栈</a><br>读后一篇文：<a href="/2017/05/27/javascript/深入理解JavaScript错误与调用栈/">深入理解 JavaScript 错误与调用栈</a></p><hr>]]></content>
      
      <categories>
          
          <category> 阅读精选 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ES7修饰器</title>
      <link href="/2017/05/29/knowledge/ES7%E4%BF%AE%E9%A5%B0%E5%99%A8/"/>
      <url>/2017/05/29/knowledge/ES7%E4%BF%AE%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>ES7 修饰器(Decorator) 初认识，文章参考阮一峰老师的 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6 标准入门</a></p></blockquote><hr><h3 id="何为修饰器"><a href="#何为修饰器" class="headerlink" title="何为修饰器"></a>何为修饰器</h3><p>修饰器(<code>Decorator</code>)是一个表达式，用于修改类的行为，这是 <code>ES7</code> 的一个<a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener">提案</a>，所以在 <code>ES7</code> 规范出来之前，它的正式性还不能得到确定，但如今在许多 Node 、React 等项目中已经使用该方案，目前 Babel 转码器已经支持修饰器的使用。<br>修饰器对类的行为的改变，是在代码编译时发生的，而不是在运行时，这意味着修饰器能在编译阶段运行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MyTestableClass.isTestable); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的代码中，<code>@testable</code> 就是一个修饰器，它修改了 <code>MyTestableClass</code> 这个类的行为，为它加上了静态属性 <code>isTestable</code>。<br>基本上，修饰器的行为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，修饰器本质上就是能在编译时执行的函数，且修饰器函数的行为其实就等同于函数式编程里面的高阶函数，有兴趣的小伙伴可以跳往另一篇文章 —— <a href="https://github.com/gu-xionghong/iCoding/blob/master/2016/函数式编程/ES6的高阶函数.md" target="_blank" rel="noopener">ES6 - 高阶函数介绍</a>。</p><h3 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h3><p>上面的例子中， <code>testable</code> 函数的参数 <code>target</code> 就是所要修饰的对象，如果希望修饰器的行为能够根据目标对象的不同而不同，就要再封装一层函数，修饰器也能通过 <code>prototype</code> 属性给类添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPrototype</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testPrototype</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestPrototypeClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestPrototypeClass();</span><br><span class="line">obj.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面是另外一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    Objects.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面的代码通过修饰器 <code>mixins</code> 可以为类添加指定的方法。<br>另外，修饰器可以用 <code>Object.assign()</code> 模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><h3 id="方法的修饰"><a href="#方法的修饰" class="headerlink" title="方法的修饰"></a>方法的修饰</h3><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，修饰器函数一共可以接受 3 个参数，第 1 个参数是修饰的目标对象(<code>target</code>)，第 2 个参数是所要修饰的属性名(<code>name</code>)，第 3 个参数是该属性的描述对象(<code>descriptor</code>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// descriptor 对象默认值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//  value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//  enumerable: false,</span></span><br><span class="line">  <span class="comment">//  configurable: true,</span></span><br><span class="line">  <span class="comment">//  writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure><p>上面的代码说明，修饰器 <code>readonly</code> 会修改属性的描述对象 <code>descriptor</code>，然后被修改的描述对象再用来定义属性，下面是另一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> kidCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰器有注释的作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出， <code>Person</code> 类是可测试的，而 <code>name</code> 方法是只读和不可枚举的。<br>除了注释，修饰器还能用于类型检查，所以，对于类而言，这项功能相当有用，从长期来看，它将是 <code>Javascript</code> 代码静态分析的重要工具。</p><h3 id="React-修饰器使用"><a href="#React-修饰器使用" class="headerlink" title="React 修饰器使用"></a>React 修饰器使用</h3><p>如<a href="https://github.com/gu-xionghong/iCoding/blob/master/2016/函数式编程/ES6的高阶函数.md" target="_blank" rel="noopener">ES6 - 高阶函数介绍</a>里有介绍一些 <code>React HOC</code> 的使用方式，而针对修饰器，<code>React</code> 也能充分利用其优势进行代码的组织,下面我们将以一个 <code>Redux connect</code> 的使用作为例子代码<br>不使用修饰器 decorator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">actions</span>: bindActionCreators(actionCreators, dispatch) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...define your main app here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyApp);</span><br></pre></td></tr></table></figure><p>使用修饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">actions</span>: bindActionCreators(actionCreators, dispatch) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...define your main app here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>修饰器的使用很大程度的提高了代码的复用性及清晰性，对方法的修饰，能让我们更方便的对属性的描述对象进行操作，提升我们的代码质量，但因为修饰器现在还属于 <code>ES7</code> 提案内容，如今如果想要使用的话必须通过 <code>Babel</code> 编码器进行代码编译，这也是其弊端之一了~</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6-Arguments与Parameters用法总结</title>
      <link href="/2017/05/28/knowledge/ES6-Arguments%E4%B8%8EParameters%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2017/05/28/knowledge/ES6-Arguments%E4%B8%8EParameters%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>ES6 Arguments 与 Parameters 用法总结</p></blockquote><hr><h3 id="扩展操作符"><a href="#扩展操作符" class="headerlink" title="扩展操作符"></a>扩展操作符</h3><p>扩展操作符能将数组展开成独立的数值传给函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...myArray); <span class="comment">//  === Math.max(1,2,3);   ouput：3</span></span><br></pre></td></tr></table></figure><h3 id="Rest-参数"><a href="#Rest-参数" class="headerlink" title="Rest 参数"></a>Rest 参数</h3><p><code>rest</code> 参数和扩展操作符拥有相同的语法，不同的是，<code>rest</code> 参数是把所有的参数收集起来转换成数组，而扩展操作符是把数组扩展成单独的参数。<code>rest</code> 参数在创建一个可变函数（即一个参数个数可变的函数）时尤其有用，<code>rest</code> 参数有着数组固有的优势，可以快捷地替换 <code>arguments</code> 对象，但是 <code>rest</code> 参数必须为最后一个参数，否则会导致报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">a, ...params, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, ...params, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testable(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// StntaxError: parameter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">a, ...params &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  console.log(a, ...params</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">testable</span>(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>); // 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a = <span class="number">1</span>, b = [<span class="number">2</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(<span class="number">5</span>); <span class="comment">// 5 [2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数声明中做运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b = ++a, c = a * b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(<span class="number">5</span>); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数声明中做参数判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a = foo(</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Missing parameter'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(); <span class="comment">// 'Missing parameter'</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line">[x, y] = [y, x];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从函数返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;foo, bar&#125; = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数的定义</span></span><br><span class="line"><span class="comment">// 有序参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123;...&#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123;...&#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取 JSON 数据</span></span><br><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = jsonData;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解JavaScript错误与调用栈</title>
      <link href="/2017/05/27/knowledge/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2017/05/27/knowledge/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>探讨错误（Error）和调用栈踪迹（stack trace)以及如何对它们进行操作。</p></blockquote><hr><p>原文地址: <a href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html" target="_blank" rel="noopener">JavaScript Errors and Stack Traces in Depth</a><br>知乎翻译: <a href="https://zhuanlan.zhihu.com/p/27127139" target="_blank" rel="noopener">深入理解 JavaScript 错误与调用栈</a></p><p>这篇文章主要讲解了</p><ol><li><a href="#调用栈的工作原理">调用栈的工作原理</a></li><li><a href="#Error对象以及错误处理">Error 对象以及错误处理</a></li><li><a href="#操作调用栈踪迹">操作调用栈踪迹(Error.captureStackTrace 的使用)</a></li></ol><h3 id="调用栈的工作原理"><a href="#调用栈的工作原理" class="headerlink" title="调用栈的工作原理"></a>调用栈的工作原理</h3><p>这部分主要了解了 JS 函数调用<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">栈</a>的工作原理,在 JS 中追踪堆栈可使用 <code>console.trace</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后执行函数会处于栈顶,执行结束后会被移除,LIFO</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace</span></span><br><span class="line"><span class="comment">//   at c (repl:3:9)</span></span><br><span class="line"><span class="comment">//   at b (repl:3:1)</span></span><br><span class="line"><span class="comment">//   at a (repl:3:1)</span></span><br><span class="line"><span class="comment">//   at repl:1:1</span></span><br><span class="line"><span class="comment">//   ....</span></span><br></pre></td></tr></table></figure><h3 id="Error-对象以及错误处理"><a href="#Error-对象以及错误处理" class="headerlink" title="Error 对象以及错误处理"></a>Error 对象以及错误处理</h3><p>该部分主要讲解 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">Error</a> 的使用,如何 <code>throw</code> 一个异常,如何 <code>catch</code>、<code>finally</code> 一个异常以及 <code>Error</code> 的较好实践(不抛出非<code>Error</code>实例异常、传递<code>Error</code>实例方式、<code>Promise</code>里<code>reject</code>错误对象等)。</p><h3 id="操作调用栈踪迹"><a href="#操作调用栈踪迹" class="headerlink" title="操作调用栈踪迹"></a>操作调用栈踪迹</h3><p>该部分主要讲解了 <code>Error.captureStackTrace</code> 方法的使用方式(仅 v8 引擎支持)，合理利用这个方法,可以对你的用户隐藏与他无关的框架实现细节</p><blockquote><p>Error.captureStackTrace(targetObject[, constructorOpt])<br>在 targetObject 中添加一个.stack 属性.对该属性进行访问时,将以字符串的形式返回 Error.captureStackTrace()语句被调用时的代码位置信息(即：调用栈历史),如果传入了第二个参数,传入的函数会被视作调用栈的终点,于是调用栈踪迹就只会显示该函数调执行前的部分.</p></blockquote><h4 id="new-Error-stack-vs-Error-captureStackTrace"><a href="#new-Error-stack-vs-Error-captureStackTrace" class="headerlink" title="new Error().stack vs Error.captureStackTrace"></a>new Error().stack vs Error.captureStackTrace</h4><p>new Error().stack 的适用范围会更加广泛，而 Error.captureStackTrace 只能在 Node.js 或者 Chrome 上使用。<br>在两者都能使用的情况下，优先使用 Error.captureStackTrace，原因为：</p><ul><li>无需 new 一个新的 Error 对象，节省内存空间，同时代码上也会更加优雅。</li><li>如果需要忽略部分堆栈信息，使用 Error.captureStackTrace 会更加方便，无需手工操作。</li><li>如果使用 Error.captureStackTrace,则对于堆栈信息的格式化工作会被延迟至访问 targetObj.stack 时进行，如果 targetObj.stack 未被访问，则堆栈信息的格式化工作会被省略，从而节省计算资源。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例，引自Chai框架</span></span><br><span class="line"><span class="comment">// `ssf` 代表 "start stack function"。 从这里开始从调用栈里移除不相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssertionError</span>(<span class="params">message, _props, ssf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extend = exclude(<span class="string">'name'</span>, <span class="string">'message'</span>, <span class="string">'stack'</span>, <span class="string">'constructor'</span>, <span class="string">'toJSON'</span>),</span><br><span class="line">    props = extend(_props || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认值</span></span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'Unspecified AssertionError'</span>;</span><br><span class="line">  <span class="keyword">this</span>.showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制props</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = props[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一下是我们关注的内容：</span></span><br><span class="line">  <span class="comment">// 如果传入了ssf，就传递给captureStackTrace来移除它之后的内容</span></span><br><span class="line">  ssf = ssf || <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">if</span> (ssf &amp;&amp; <span class="built_in">Error</span>.captureStackTrace) &#123;</span><br><span class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, ssf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有，就使用原始的stack属性</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stack = e.stack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，如果提供了调用栈开始函数，我们使用 Error.captureStackTrace 来捕捉调用栈然后保存到 AssertionError 实例里，并从调用栈移除不相关内容（都是 Chai 的内部实现细节，只会污染栈信息）。</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Underscore源码解析3 — 集合函数</title>
      <link href="/2017/05/26/sourceAnalysis/underscore/underscore-3/"/>
      <url>/2017/05/26/sourceAnalysis/underscore/underscore-3/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>本系列将对 <a href="https://github.com/jashkenas/underscore/tree/1.8.3" target="_blank" rel="noopener">Underscore v1.8.3</a> 进行源码解读，并通过部分测试用例作进一步分析，更多可访问 <a href="/tags/Underscore/">Underscore 源码解读</a></p></blockquote><hr><p>Underscore 是一个 JavaScript 实用库，提供了一整套函数式编程的实用功能，它体积小、能力强，性价比极高，包容部分函数式编程思想。该篇文章将以 <em>代码 + 注释 + 总结</em> 的形式对其 <em>集合函数</em> 做分析。</p><h3 id="each-Alias-forEach"><a href="#each-Alias-forEach" class="headerlink" title="each Alias: forEach"></a><em>each</em> Alias: <em>forEach</em></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组|对象|类数组对象的每个元素，</span></span><br><span class="line"><span class="comment">// 并将其(element, index, list)传入iteratee执行</span></span><br><span class="line"><span class="comment">// 对象则传入(value, key, list)</span></span><br><span class="line"><span class="comment">// 若context不为空，则将iteratee绑定到context身上执行</span></span><br><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = optimizeCb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="map-Alias-collect"><a href="#map-Alias-collect" class="headerlink" title="map Alias: collect"></a><em>map</em> Alias: <em>collect</em></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组|对象|类数组对象的每个元素</span></span><br><span class="line"><span class="comment">// 将其作为参数传入iteratee(经过cb内置函数转化)</span></span><br><span class="line"><span class="comment">// 最终返回所有的计算结果数组</span></span><br><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">    length = (keys || obj).length,</span><br><span class="line">    results = <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="reduce-amp-amp-reduceRight"><a href="#reduce-amp-amp-reduceRight" class="headerlink" title="reduce &amp;&amp; reduceRight"></a><em>reduce</em> &amp;&amp; <em>reduceRight</em></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReduce</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">obj, iteratee, memo, keys, index, length</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 按顺序对每一个元素都执行iteratee，并返回处理后结果，返回最终memo</span></span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">    iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据memo传值情况初始化memo</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iterator(obj, iteratee, memo, keys, index, length);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</span><br><span class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>把集合中元素归结为一个单独的数值并返回。<code>Memo</code>是<code>reduce</code>函数的初始值，<code>reduce</code>的每一步都需要由<code>iteratee</code>返回。这个迭代传递 4 个参数：<code>memo</code>,<code>value</code> 和 迭代的<code>index</code>（或者 <code>key</code>）和最后一个引用的整个集合数据,<code>reduceRight</code>为逆序进行<code>reduce</code></p><h3 id="find-Alias-detect"><a href="#find-Alias-detect" class="headerlink" title="find Alias: detect"></a><em>find</em> Alias: <em>detect</em></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回第一个通过predicate迭代函数真值检测的元素值，</span></span><br><span class="line"><span class="comment">// 如果没有值传递给测试迭代器将返回undefined。</span></span><br><span class="line"><span class="comment">// 如果找到匹配的元素，函数将立即返回，不会遍历整个list</span></span><br><span class="line">_.find = _.detect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    key = _.findIndex(obj, predicate, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = _.findKey(obj, predicate, context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; key !== <span class="number">-1</span>) <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Underscore源码解析2 — 内置函数</title>
      <link href="/2017/05/26/sourceAnalysis/underscore/underscore-2/"/>
      <url>/2017/05/26/sourceAnalysis/underscore/underscore-2/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>本系列将对 <a href="https://github.com/jashkenas/underscore/tree/1.8.3" target="_blank" rel="noopener">Underscore v1.8.3</a> 进行源码解读，并通过部分测试用例作进一步分析，更多可访问 <a href="/tags/Underscore/">Underscore 源码解读</a></p></blockquote><hr><p>Underscore 是一个 JavaScript 实用库，提供了一整套函数式编程的实用功能，它体积小、能力强，性价比极高，包容部分函数式编程思想。该篇文章将以 <em>代码 + 注释 + 总结</em> 的形式对其 <em>内置函数</em> 做分析。</p><h3 id="回调优化-optimizeCb"><a href="#回调优化-optimizeCb" class="headerlink" title="回调优化 - optimizeCb"></a>回调优化 - optimizeCb</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以修改函数的执行环境跟限制传参序列、数量的形式优化回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;Function&#125; func     回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125; context   上下文</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; argCount  参数长度</span></span><br><span class="line"><span class="comment"> * @return &#123;Function&#125;         新的callback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, value);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, other</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, value, other);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>optimizeCb</code>主要通过对回调函数<code>func</code>绑定上下文<code>context</code>的方式实现优化，其可以让解析器在解析<code>func</code>时，不需要一层层追溯<code>func</code>的上下文，在调用次数达到一定量时，该优化还是有意义的。</p><h3 id="回调分类-cb"><a href="#回调分类-cb" class="headerlink" title="回调分类 - cb"></a>回调分类 - cb</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 空类型，返回一个返回vuale的默认迭代器</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br><span class="line">  <span class="comment">// function类，对回调函数做优化</span></span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</span><br><span class="line">  <span class="comment">// Object类，返回属性匹配器</span></span><br><span class="line">  <span class="keyword">if</span> (_.isObject(value)) <span class="keyword">return</span> _.matcher(value);</span><br><span class="line">  <span class="comment">// 其余情况。返回属性访问器</span></span><br><span class="line">  <span class="keyword">return</span> _.property(value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对<code>value</code>的类型不同，返回不同的回调函数，或为默认迭代器(<a href>__.identity_</a>)，任意回调(<a href="#optimizeCb"><em>optimizeCb</em></a>)，属性匹配器(<a href>__.matcher_</a>)或属性访问器(<a href>__.property_</a>) <em>todo</em></p><h3 id="属性分配器-createAssigner"><a href="#属性分配器-createAssigner" class="headerlink" title="属性分配器 - createAssigner"></a>属性分配器 - createAssigner</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性分配器</span></span><br><span class="line"><span class="comment"> * @param  &#123;Function&#125; keysFunc     object属性读取方法(_.keys | _.allKeys)</span></span><br><span class="line"><span class="comment"> * @param  &#123;Boolean&#125; undefinedOnly 是否只分配原object里undefined的属性 true/false</span></span><br><span class="line"><span class="comment"> * @return &#123;Function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> createAssigner = <span class="function"><span class="keyword">function</span>(<span class="params">keysFunc, undefinedOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="comment">// 参数长度小于2或obj为null，则返回原参数</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 遍历所有参数属性，并进行分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index],</span><br><span class="line">        keys = keysFunc(source),</span><br><span class="line">        l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!undefinedOnly || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历属性并插入到原 obj 里，可用于合并对象或拷贝对象</p><h3 id="类式继承-baseCreate"><a href="#类式继承-baseCreate" class="headerlink" title="类式继承 - baseCreate"></a>类式继承 - baseCreate</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类式继承，返回一个新的对象</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125; prototype 原型对象</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125;           新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isObject(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype);</span><br><span class="line">  Ctor.prototype = prototype;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor();</span><br><span class="line">  Ctor.prototype = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create</a> 的兼容性写法</p><h3 id="属性获取器-property"><a href="#属性获取器-property" class="headerlink" title="属性获取器 - property"></a>属性获取器 - property</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性获取器</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; key   需要获取的key值</span></span><br><span class="line"><span class="comment"> * @return &#123;Function&#125;     获取obj特定属性的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> property = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类数组判断-isArrayLike"><a href="#类数组判断-isArrayLike" class="headerlink" title="类数组判断 - isArrayLike"></a>类数组判断 - isArrayLike</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span>(<span class="params">collection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用来判断 <code>collection</code> 是否为类数组，从而选择数组或对象形式对其做对应迭代操作</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>代码分析是根据代码结构顺序依次往下，大致翻阅发现后面还有一些内置函数，故将跟随系列持续更新该篇文章 <em>todo</em></p>]]></content>
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Underscore源码解析1 — 基础配置</title>
      <link href="/2017/05/25/sourceAnalysis/underscore/underscore-1/"/>
      <url>/2017/05/25/sourceAnalysis/underscore/underscore-1/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>本系列将对 <a href="https://github.com/jashkenas/underscore/tree/1.8.3" target="_blank" rel="noopener">Underscore v1.8.3</a> 进行源码解读，并通过部分测试用例作进一步分析，更多可访问 <a href="/tags/Underscore/">Underscore 源码解读</a></p></blockquote><hr><p>Underscore 是一个 JavaScript 实用库，提供了一整套函数式编程的实用功能，它体积小、能力强，性价比极高，源码长度只需要 1000 多行，最近刚好在学习 <em>函数式编程</em>，所以选择了 <em>Underscore</em> 作为博客开篇第一系列。该篇文章将以 <em>代码 + 注释 + 总结</em> 的形式对其 <em>基础配置</em> 做分析。</p><h3 id="IIFE-隔离作用域"><a href="#IIFE-隔离作用域" class="headerlink" title="IIFE 隔离作用域"></a>IIFE 隔离作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;.call(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>通过 IIFE 隔离作用域，防止全局污染，通过 <em>call</em> 将作用域 <em>this</em> 指向当前环境(浏览器端为 <em>window</em>，nodejs 环境指向 <em>exports</em>)</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建root对象，用来接收this指向，this内容参考上级说明</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过previousUnderscore变量缓存环境中之前的 _ 属性</span></span><br><span class="line"><span class="keyword">var</span> previousUnderscore = root._;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内置对象的原型链缓存在局部变量, 方便快速调用，缩小文件体积</span></span><br><span class="line"><span class="keyword">var</span> ObjProto = <span class="built_in">Object</span>.prototype,</span><br><span class="line">  ArrayProto = <span class="built_in">Array</span>.prototype,</span><br><span class="line">  FuncProto = <span class="built_in">Function</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内置对象原型中的常用方法缓存在局部变量, 方便快速调用</span></span><br><span class="line"><span class="keyword">var</span> push = ArrayProto.push,</span><br><span class="line">  slice = ArrayProto.slice,</span><br><span class="line">  toString = ObjProto.toString,</span><br><span class="line">  hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存将使用到的ES5方法</span></span><br><span class="line"><span class="comment">// 如果宿主环境中支持这些方法则优先调用, 如果宿主环境中没有提供, 则会由Underscore实现</span></span><br><span class="line"><span class="keyword">var</span> nativeIsArray = <span class="built_in">Array</span>.isArray,</span><br><span class="line">  nativeKeys = <span class="built_in">Object</span>.keys,</span><br><span class="line">  nativeBind = FuncProto.bind,</span><br><span class="line">  nativeCreate = <span class="built_in">Object</span>.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的构造函数，用于做prototype交换/替换操作时缓存属性</span></span><br><span class="line"><span class="keyword">var</span> Ctor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新声明安全的_对象（覆盖全局_对象），并提供给下面代码使用</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</span><br><span class="line">  <span class="keyword">this</span>._wrapped = obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同的宿主环境, 将Undersocre的命名变量存放到不同的对象中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">    exports = <span class="built_in">module</span>.exports = _;</span><br><span class="line">  &#125;</span><br><span class="line">  exports._ = _;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  root._ = _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本声明</span></span><br><span class="line">_.VERSION = <span class="string">'1.8.3'</span>;</span><br></pre></td></tr></table></figure><ol><li>缓存变量，达到不污染原数据、清晰化代码、缩小文件体积等作用</li><li>通过空构造函数实现 <em>prototype</em> 的替换操作</li><li>重新声明 ___ 变量，防止恶意攻击，___ 函数内部的方法暂未明白有何作用，_todo_</li><li>针对不同的宿主环境, 将命名变量存放到不同的对象中(<em>exports</em> or <em>global variable</em>)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过基本配置我们了解到了框架开发的一些基础知识，包括作用域隔离、安全防护、框架导出等，下一期我们将从 <em>Undersocre</em> 的一些内置函数下手，体验函数式编程的快感~</p>]]></content>
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise - 告别无尽回调</title>
      <link href="/2017/05/25/knowledge/Promise-%E5%91%8A%E5%88%AB%E6%97%A0%E5%B0%BD%E5%9B%9E%E8%B0%83/"/>
      <url>/2017/05/25/knowledge/Promise-%E5%91%8A%E5%88%AB%E6%97%A0%E5%B0%BD%E5%9B%9E%E8%B0%83/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>跟无尽回调 say bye bye~</p></blockquote><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本文将参考 <a href="http://liubin.org/promises-book/#" target="_blank" rel="noopener">JavaScript Promise 迷你书</a>，以 <a href="https://tc39.github.io/ecma262/#sec-promise-objects" target="_blank" rel="noopener">ES6 Promises</a> 规范，即 JavaScript 的标准规范为基础的 <code>Promise</code> 的相关内容及使用方法。</p><h4 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h4><p><code>Promise</code> 是抽象异步处理对象以及对其进行各种操作的组件，它能以优雅的方式实现异步操作，看看不使用 <code>Promise</code>，实现回调的情况是如何</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn、fn1、fn2、fn3方法均接受一个回调函数</span></span><br><span class="line"><span class="comment">// 需要的执行顺序为 fn =&gt; fn1 =&gt; fn2 =&gt; fn3</span></span><br><span class="line"><span class="comment">// 接受回调吧！ BOOM ！！！ 😨😨</span></span><br><span class="line">fn(</span><br><span class="line">  fn1(</span><br><span class="line">    fn2(</span><br><span class="line">      fn3(</span><br><span class="line">        ...</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后我们再来看下使用 <code>Promise</code> 实现会如何</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瞬间清爽~~ 🍉🍉🍉🍉</span></span><br><span class="line">fn()</span><br><span class="line">  .then(fn1())</span><br><span class="line">  .then(fn2())</span><br><span class="line">  .then(fn3());</span><br></pre></td></tr></table></figure><p><code>Promise</code> 在解决无尽回调之外，更大的作用是方便我们去控制我们异步使用，虽仅有几个 API，但也能非常自由的控制我们的异步逻辑。</p><h3 id="Promise-实践"><a href="#Promise-实践" class="headerlink" title="Promise 实践"></a>Promise 实践</h3><h4 id="创建-promise-对象"><a href="#创建-promise-对象" class="headerlink" title="创建 promise 对象"></a>创建 promise 对象</h4><p>创建 <code>promise</code> 有下面几种方式：</p><ol><li>实例化 <code>Promise</code> 对象:<code>const promise = new Promise((resolve, reject) =&gt; {});</code></li><li><code>Promise.resolve()</code></li><li><code>Promise.reject()</code></li><li><code>Promise.all([])</code></li><li><code>Promise.race([])</code></li></ol><p>本文将以第一点的 <code>Promise实例</code> 为例子进行展开学习，剩下的均为 <code>Promise</code> 的静态方法，使用方式在 <code>实例</code> 的基础上有所拓展，具体的使用方式可参考 <a href="http://liubin.org/promises-book/#promise-api-reference" target="_blank" rel="noopener">Promises API Reference</a>。</p><h4 id="resolve-reject"><a href="#resolve-reject" class="headerlink" title="resolve, reject"></a>resolve, reject</h4><p>在上面创建过程中，我们在实例化时传入了一个回调函数，回调函数接受了两个参数:<code>resolve</code>、<code>reject</code>，这两个小家伙有什么作用呢？让我们先看看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt; <span class="number">100</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'延时需要大于100ms'</span>));</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'done'</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="built_in">console</span>.log(msg))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="comment">// 1000ms后输出 done</span></span><br><span class="line"></span><br><span class="line">timeout(<span class="number">50</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="built_in">console</span>.log(msg))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="comment">// Error: 延时需要大于100ms</span></span><br></pre></td></tr></table></figure><p>当 <code>promise</code> 被 <code>resolve</code> 的时候，将触发 <code>onFulfilled</code> 事件，此时将告知 <code>promise</code> 可以往下执行 <code>then</code> 方法了，<code>resolve</code> 的参数将作为 <code>then</code> 方法里面函数的参数，同理, <code>reject</code> 将触发 <code>onRejected</code> 事件，告知执行 <code>catch</code> 方法，参数传递方式一样。<br><img src="http://liubin.org/promises-book/Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png" alt="resolve、reject"><br>所以 <code>promise</code> 更像是定义了一套钩子(hook) 函数，可以自主的控制什么时候讲进行下一步流程函数的执行。</p><h4 id="then-catch-方法将返回新创建的-Promise-对象"><a href="#then-catch-方法将返回新创建的-Promise-对象" class="headerlink" title="then/catch 方法将返回新创建的 Promise 对象"></a>then/catch 方法将返回新创建的 Promise 对象</h4><p><code>then/catch</code> 方法将返回新创建的 <code>Promise</code> 对象,因此我们可以根据这个特性进行一连串的方法连的调用。<br><img src="http://liubin.org/promises-book/Ch2_HowToWrite/img/then_catch.png" alt="then/catch"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上行函数的输出将作为下行函数的输入，同 gulp pipe</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2: '</span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Deferred-and-Promise"><a href="#Deferred-and-Promise" class="headerlink" title="Deferred and Promise"></a>Deferred and Promise</h3><p>使用过 Jquery Deferred 的各位应该都对 <code>Deferred</code> 不陌生了，<code>Deferred</code> 和 <code>Promise</code> 不同，它没有共通的规范，每个 Library 都是根据自己的喜好来实现的。</p><h4 id="Deferred-和-Promise-的关系"><a href="#Deferred-和-Promise-的关系" class="headerlink" title="Deferred 和 Promise 的关系"></a>Deferred 和 Promise 的关系</h4><p>简单来说，<code>Deferred</code> 和 <code>Promise</code> 具有如下的关系</p><ul><li><code>Deferred</code> 拥有 <code>Promise</code></li><li><code>Deferred</code> 具备对 <code>Promise</code> 的状态进行操作的特权方法<br><img src="http://liubin.org/promises-book/Ch4_AdvancedPromises/img/deferred-and-promise.png" alt="Deferred/Promise"></li></ul><h4 id="Deferred-状态操作特权"><a href="#Deferred-状态操作特权" class="headerlink" title="Deferred 状态操作特权"></a>Deferred 状态操作特权</h4><p><code>Deferred</code> 允许将 <code>Promise</code> 实例化到一个变量上，并赋予这个变量 <code>resolve</code> 及 <code>reject</code> 方法，让其在任何时刻都可以改变 Promise 状态（<code>Promise</code> 需要在参数回调内才可改变）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  <span class="keyword">if</span> (ms &lt; <span class="number">100</span>) deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'延时需要大于100ms'</span>));</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    deferred.resolve(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deferred-实现"><a href="#Deferred-实现" class="headerlink" title="Deferred 实现"></a>Deferred 实现</h4><p>基于 <code>Promise</code> 实现 <code>Deferred</code> 还是比较容易理解的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>._resolve = resolve;</span><br><span class="line">      <span class="keyword">this</span>._reject = reject;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._resolve.call(<span class="keyword">this</span>.promise, value);</span><br><span class="line">&#125;;</span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._reject.call(<span class="keyword">this</span>.promise, reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>差不多是这样了~下次更新 <code>async/await</code> 使用</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
