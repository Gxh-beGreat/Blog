---
title: JavaScript语言精粹 - 函数篇(一)
date: 2017-07-28 14:57:27
toc: true
categories:
- JavaScript
tags:
- JavaScript语言精粹
- JavaScript
---
-----

> JavaScript语言精粹 - 函数篇(一),基础篇

-----

## 函数对象(Function Objects)
`JavaScript` 中的函数即是对象,对象字面量产生的对象连接到 `Object.prototype`,函数对象连接到 `Function.prototype` (该原型对象本身连接到 `Object.prototype`)，每个函数在创建时会附加两个隐藏属性： 函数的 _上下文_ 和 _实现函数行为的代码_(调用函数时即调用该 `调用` 属性)  
每个函数对象在创建时也随配有一个 `prototype` 属性，它的值是一个拥有 `constructor` 属性且值为该函数的对象  
函数的与众不同之处在于它们可以被调用

## 调用(Invocation)
调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数: `this` 和 `arguments`。参数 `this` 在面向对象编程中非常重要，它的值取决于调用的模式。在 `JavaScript` 中一共有 _4_ 中调用模式:`方法调用`、`函数调用`、`构造器调用` 和 `apply 调用`。这些模式在如何初始化关键参数 `this` 上存在差异

### 方法调用模式(The Method Invocation Pattern)
当一个函数被保存为对象的一个属性时，我们称它为一个 `方法`。当一个方法被调用时，`this` 被绑定到该对象，如果调用表达式包含一个 _提取属性_ 的动作(即包含一个 `.` 点表达式或 `[subscript]` 下标表达式),那么它就是被当做一个方法来调用。
```javascript
const myObject = {
    value: 0,
    increment: function (inc) {
        this.value += typeOf inc === 'number' ? inc : 1
    }
}

myObject.increment()
myObject.value // 1

myObject.increment(2)
myObject.value // 3
```
方法可以使用 `this` 访问自己所属的对象，`this` 到对象的绑定发生在 _调用_ 的时候，这个"超级"延迟绑定(`vary late binding`) 使得函数可以对 `this` 高度复用。通过 `this` 可取得它们所属对象的上下文的方法称为公共方法(`public method`)。

### 函数调用模式(The Function Invocation Pattern)
当一个函数并非一个对象的属性时，那么它将被当做一个函数来调用：
```javascript
// add 函数将返回两个传入参数的相加值
const sum = add(3, 4)
```
通过该模式调用函数时，`this` 被绑定到全局对象。_这是语言设计上的一个错误_。倘若语言设计正确，那么当内部函数被调用时，`this` 应该仍然绑定到外部函数的 `this` 变量。这个设计错误的后果就是方法不能利用内部函数来帮助它工作，因为内部函数的 `this` 被绑定了错误的值，所以不能共享该方法对对象的访问权。幸运的是，有一个很容易的解决方案：如果该方法定义一个变量并给它赋值为 `this`,那么内部函数就可以通过那个变量访问到 `this`。
```javascript
myObject.double = function () {
    const that = this
    const helper = function () {
        that.value = add(that.value, that.value)
    }
    helper()
}

myObject.double()
myObject.value // 6
```

### 构造器调用模式(The Constructor Invocation Pattern)
如果在一个函数前面带上 `new` 来调用，那么背地里将会创建一个连接到该函数的 `prototype` 成员的新对象，同时 `this` 会被绑定到那个新对象上  
`new` 前缀也会改变 `return` 语句的行为
```javascript
// 每个函数对象在创建时也随配有一个 `prototype` 属性，它的值是一个拥有 `constructor` 属性且值为该函数的对象
const Quo = function (string) {
    this.status = string
}
Quo.prototype.get_status = function () {
    return this.status
}

// 构造一个 Quo 实例
const myQuo = new Quo('confused')
myQuo.get_status() // 'confused'
```
该调用模式调用的函数被称为 `构造器函数`,一般约定以 _首字母大写_ 的命名方式命名，但是这种形式的构造器函数并不推荐，我们将在后续的学习中学习到更优的替代方式

### Apply调用模式(The Apply Invocation Pattern)
`JavaScript` 是一门函数式的面向对象编程语言，即函数可以拥有自己的方法。  
`apply` 方法让我们构建一个参数数组传递给调用函数，它也允许我们选择 `this` 的值。`apply` 方法接受两个参数，第一个是要绑定给 `this` 的值，第二个是一个`参数数组`
```javascript
const array = [3, 4]
const sum = add.apply(null, array) // 7

const statusObj = {
    status: 'A-OK'
}
Quo.prototype.get_status.apply(statusObj) // 'A-OK'
```

## 参数(Arguments)
当函数被调用时，会得到一个“免费”配送的参数 —— `arguments`,它是一个类数组，用有一个 `length` 属性，但没有任何数组的方法，函数可以通过此参数访问所有它被调用时传递给它的参数列表:
```javascript
const sum = function () {
    let sum = 0
    for (let i = 0; i < arguments.length; i++) {
        sum += arguments[i]
    }
    return sum
}
sum(1, 2, 3) // 6
```
这不是一种特别有用的模式，之后我们将学习如何给数组添加一个相似的方法达到同样的效果。  

## 返回(Return)
如果函数调用时在前面加上了 `new` 前缀，且返回值不是一个对象，则返回 `this` (该新对象)

下一篇文章我们将学习关于函数的一些较高级的用法。
