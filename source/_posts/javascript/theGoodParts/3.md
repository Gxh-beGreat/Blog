---
title: JavaScript语言精粹 - 函数篇(二)
date: 2017-07-29 17:07:10
toc: true
categories:
- JavaScript
tags:
- JavaScript语言精粹
- JavaScript
---
-----

> JavaScript语言精粹 - 函数篇(二)，高级篇

-----

这篇文章我们将学习类型功能的扩展、递归的使用、闭包、级联、柯里化等函数的高级特性及用法

## 扩展类型的功能(Augmenting Types)
`JavaScript` 允许给 _基本类型_ 扩充功能，在对象篇，我们了解到可以通过修改 `Object.prototype`, 使得所有对象都能继承到该改变。这样的方式对函数、数组、字符串、数字、正则和布尔值同样适用。  
举例来说,我们可以通过 `Function.prototype` 增加方法来使得该方法对所有函数可用:
```javascript
Function.prototype.method = function (name, func) {
    this.prototype[method] = func
    return this
}
```
通过给 `Function.prototype` 增加 `method` 方法，我们下次给对象增加方法的时候就不必键入 `prototype` 这几个字符，省掉了一些麻烦

## 递归(Recursion)
递归函数就是会直接或间接地调用自身的一种函数。
```javascript
// 汉诺塔
const hanoi = function (disc, src, aux, dst) {
    if (disc > 0) {
        hanoi(disc - 1, src, dst, aux)
        console.log(`Move disc ${disc} from ${src} to ${dst}`)
        hanoi(disc - 1, aux, src, dst)
    }
}
```
一些语言提供了`尾递归`优化，这意味着如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，可显著提高速度，但 `JavaScript` 当前没有提供尾递归优化，深度递归的函数可能会因为堆栈溢出而运行失败。
```javascript
// 构建一个带尾递归的函数
function factorial (i, a = 1) {
    if (i < 2) return a
    return factorial(i - 1, a * i)
}

factorial(4) // 24
```

## 闭包(Closure)
因为作用域的关系，函数可以访问它被创建时所处的上下文环境，上下文环境中的参数被函数使用时，该参数不会被销毁，并被函数直接访问，这种模式被称为 `闭包`，我们可以使用 `闭包` 的方式去封装一些私有属性、方法
```javascript
const myObject = (function () {
    let value = 0
    return {
        increment (inc) {
            value += typeof inc === 'number' ? inc : 1
        },
        getValue () {
            return value
        }
    }
})()
```

## 级联(Cascade)
如果我们让 _方法_ 返回返回 `this`，则可以实现 `级联`，即 `链式调用`
```javascript
const myObject = {
    value: 0,
    increment (inc) {
        this.value += typeof inc === 'number' ? inc : 1
        return this
    },
    reduce (inc) {
        this.value -= typeof inc === 'number' ? inc : 1
        return this
    },
    getValue () {
        return this.value
    }
}

myObject.increment(3).reduce(2).increment(1).getValue() // 2
```

## 柯里化(Curry)
`柯里化` 是函数式编程常用的方式，它允许我们把函数与传递给它的参数相结合，产生出一个新的函数
```javascript
const add1 = add.curry(1)
add1(6) // 7
```
`JavaScript` 没有 `curry` 方法，但我们可以给 `Function.prototype` 扩充此功能
```javascript
Function.method('curry', function (...args) {
    // 这里的this指向函数自身
    return function (...args2) {
        return this.apply(null, args.concat(args2))
    }.bind(this)
})
```

## 记忆(Memoization)
